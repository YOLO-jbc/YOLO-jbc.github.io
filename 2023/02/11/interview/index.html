

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jumping">
  <meta name="keywords" content="">
  
    <meta name="description" content="总结C++面试相关问题">
<meta property="og:type" content="article">
<meta property="og:title" content="interview">
<meta property="og:url" content="http://yolo-jbc.github.io/2023/02/11/interview/index.html">
<meta property="og:site_name" content="Jumping&#39;s Blog">
<meta property="og:description" content="总结C++面试相关问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yolo-jbc.github.io/img/Algorithm/graph/search.jpg">
<meta property="article:published_time" content="2023-02-11T04:47:38.000Z">
<meta property="article:modified_time" content="2023-02-26T12:36:48.534Z">
<meta property="article:author" content="Jumping">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yolo-jbc.github.io/img/Algorithm/graph/search.jpg">
  
  
  
  <title>interview - Jumping&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yolo-jbc.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jumping&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="interview"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-11 12:47" pubdate>
          2023年2月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          114 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">interview</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="△-210次-简述-C-中智能指针的特点，简述-new-与-malloc-的区别">△ 210次 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别</h4>
<p>C++ 中的智能指针是一种更高级的内存管理工具，它在 C++11 标准中被引入。智能指针的特点如下：</p>
<p>自动管理内存：智能指针可以自动管理分配的内存，在没有任何引用指向该内存时自动释放内存。</p>
<p>避免内存泄漏：因为智能指针会自动管理内存，所以可以避免内存泄漏的情况。</p>
<p>方便使用：智能指针可以像普通指针一样使用，不需要手动释放内存。</p>
<p>安全性：智能指针可以避免空指针和重复释放内存的错误。</p>
<ol>
<li>
<p><code>uniqued_ptr</code> 作用域指针，指针变量作用域结束自动释放内存</p>
</li>
<li>
<p><code>shared_ptr</code> 实现的方式取决于编译器和在编译器中使用地标准库。但基本都是引用计数法：引用计数会追踪指针有多少个引用，一旦数量为零就会删除指针所指向的内存空间。</p>
<p>和 <code>unique_ptr</code> 一样由于异常安全的原因而不推荐使用 <code>new</code> 的方式创建智能指针不同，因为 <code>shared_ptr</code> 需要分配另一块内存，称为控制块，用来存储引用计数，所以如果使用 <code>new</code> 的形式来创建一个对象再将其传给 <code>shared_ptr</code> 的构造函数，他就必须做两次内存分配。</p>
</li>
<li>
<p><code>weak_ptr</code> 和复制 <code>shared_ptr</code> 所做的一样，但当你把 <code>shared_ptr</code> 赋值给一个 <code>weak_ptr</code>，假如唯一的那个 <code>shared_ptr</code> 指针死去，内存就会被删除，因为赋值给 <code>weak_ptr</code> 并不会增加引用数量。例如你在排序一个集合，你不需要关注指针是否有效，你只需要存储一个他们的引用就好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Shape</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;created shape &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete shape&quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//智能指针变量e1的生存期到头自动释放堆上的内存</span><br>        unique_ptr&lt;Shape&gt; e1 = <span class="hljs-built_in">make_unique</span>&lt;Shape&gt;(<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>    &#123;<br>        weak_ptr&lt;Shape&gt; e2;<br>        &#123;<br>            shared_ptr&lt;Shape&gt; e3 = <span class="hljs-built_in">make_shared</span>&lt;Shape&gt;(<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//由于e2是weak_ptr所以不会增加e3的引用计数，e3只有一个引用所以e3的生命期结束之后会delete shape2，再输出ok</span><br>            e2 = e3;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// created shape 1</span><br><span class="hljs-comment">// delete shape1</span><br><span class="hljs-comment">// ok</span><br><span class="hljs-comment">// created shape 2</span><br><span class="hljs-comment">// delete shape2</span><br><span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>C++ 中的 <code>new</code> 和 C 语言中的 <code>malloc</code> 都是用来动态分配内存的，但是它们有一些不同的地方：</p>
<ol>
<li><code>new</code>是运算符而<code>mallloc</code>是函数</li>
<li>内存初始化： <code>new</code> 可以自动调用构造函数对内存进行初始化，而 <code>malloc</code> 不能调用构造函数。</li>
<li>类型安全性： <code>new</code> 操作是类型安全的，因为它需要指定内存类型；而 <code>malloc</code> 操作则不是类型安全的，因为它返回的是一个通用指针需要通过强制类型转换将<code>void*</code>指针转换成我们需要的类型。。</li>
<li>内存的释放： <code>new</code> 分配的内存需要调用 <code>delete</code> 进行释放，而 <code>malloc</code> 分配的内存需要调用 <code>free</code> 进行释放。</li>
<li>分配失败返回值：<code>new</code>内存分配失败时，会抛出<code>bac_alloc</code>异常，它不会返回NULL；<code>malloc</code>分配内存失败时返回<code>NULL</code>。</li>
<li>是否需要指定内存大小：使用<code>new</code>操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而<code>malloc</code>则需要显式地指出所需内存的尺寸。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;...&#125;<br>A * ptr = <span class="hljs-keyword">new</span> A;<br>A * ptr = (A *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(A)); <span class="hljs-comment">//需要显式指定所需内存大小sizeof(A);</span><br></code></pre></td></tr></table></figure>
<p>总的来说，在 C++ 中使用 <code>new</code> 比使用 <code>malloc</code> 更方便，更安全，而且更易于使用。不过如果不需要调用构造函数，或者希望得到一个通用指针，则可以使用 <code>malloc</code>。</p>
<p>此外，在 C++ 中，最好使用智能指针代替手动管理内存，因为智能指针可以更方便，更安全的管理内存。</p>
<h4 id="△-102次-C-中虚函数与纯虚函数的区别">△ 102次 C++ 中虚函数与纯虚函数的区别</h4>
<p>在 C++ 中，虚函数和纯虚函数是多态的重要实现方式。它们的主要区别如下：</p>
<ol>
<li>虚函数：虚函数是在基类中定义的一种特殊的函数，其子类可以重写它以实现多态。</li>
<li>纯虚函数：纯虚函数是一种特殊的虚函数，它仅在基类中声明，没有任何实现。纯虚函数的作用是让基类成为抽象类，不能创建基类的对象，只能创建其子类对象。其子类必须实现该纯虚函数，否则子类也是一个抽象类。含有纯虚拟函数的类称为抽象类，它不能生成对象；</li>
</ol>
<p>不同的是，虚函数可以被子类重写，而纯虚函数只能被子类重写，不能被实例化。虚函数的作用是实现多态，而纯虚函数的作用是让子类实现某些特定的功能。</p>
<p>总的来说，虚函数是用来实现多态的，含有纯虚函数的类称作抽象类。</p>
<p>虚函数和纯虚函数与虚表有关。</p>
<p>虚表（Virtual Table）是一个指针数组，每个数组元素都指向一个虚函数的地址。每个类的对象都有一个虚指针（Virtual Pointer），该指针指向该类的虚表。</p>
<p>在 C++ 中，当一个虚函数被调用时，编译器会通过该对象的虚指针找到其对应的虚表，然后根据函数在虚表中的位置调用相应的函数。因此，如果一个函数是虚函数，则其实现在运行时才能确定，这就是多态的实现方式。</p>
<p>而纯虚函数是在基类中声明的，其子类必须实现该函数，因此虚表的实现是基于纯虚函数的。</p>
<h6 id="那为什么要有虚表这个东西呢">那为什么要有虚表这个东西呢</h6>
<p>假如有两个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;I am a person&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;I am a man&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person* ptr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">man</span>();<br>	ptr1-&gt;<span class="hljs-built_in">desc</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>C++中类和操作的封装只是对于程序员而言的</strong>。而编译器编译之后其实还是面向过程的代码。编译器帮你给成员函数增加一个额外的类指针参数，运行期间传入对象实际的指针。这段程序的打印结果是<code>I am a man</code>，因为这里没有声明父类desc为虚函数，因此属于静态绑定。<strong>类的数据(成员变量)和操作(成员函数)其实还是分离的</strong>。仅从对象的内存布局来看，只能看到成员变量，看不到成员函数。因为调用哪个函数是编译期间就确定了的，编译期间只能识别父类的desc。</p>
<p>也就是说在含有虚函数的类编译期间，编译器会自动给这种类在起始位置追加一个虚表指针(称之为: vptr) 。vptr指向一个虚表(称之为: vtable 或 vtbl) ，虚表中存储了实际的函数地址。所有虚函数的的调用取的是哪个函数（地址）是在运行期间通过查虚表确定的。</p>
<p><img src="interview.assets/v2-d75b2d5cd084a5a2b89677c9b30dc03c_720w.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="△-88次-STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？">△ 88次 STL 中 <code>vector</code> 与 <code>list</code> 具体是怎么实现的？常见操作的时间复杂度是多少？</h4>
<p>STL 中的 <code>vector</code> 和 <code>list</code> 是两种不同的序列式容器，具体的实现方式如下：</p>
<ol>
<li><code>vector</code>：<code>vector</code> 是一种动态数组，其内存空间是连续的。<code>vector</code> 在元素个数不足时会自动扩容，但当 <code>vector</code> 元素数量发生变化时，整个 <code>vector</code> 都必须重新分配，这会影响 <code>vector</code> 的性能。</li>
<li><code>list</code>：<code>list</code> 是一种双向链表，它的每个元素都是一个独立的节点。当需要插入或删除元素时，只需要修改前驱和后继节点的指针，因此不会影响整个 <code>list</code>。但是，由于 <code>list</code> 元素不在一起，查找操作比 <code>vector</code> 慢。</li>
</ol>
<p>对于常见的操作，<code>vector</code> 和 <code>list</code> 的时间复杂度如下：</p>
<ol>
<li>
<p>插入：<code>vector</code> 的尾部插入的时间复杂度为 O(1)，其他位置的插入复杂度为 O(n)；<code>list</code> 的任意位置插入的时间复杂度为 O(1)。</p>
</li>
<li>
<p>删除：<code>vector</code> 的尾部删除的时间复杂度为 O(1)，其他位置的删除复杂度为 O(n)；<code>list</code> 的任意位置删除的时间复杂度为 O(1)。</p>
</li>
<li>
<p>查找：<code>vector</code> 的随机访问的时间复杂度为 O(1)，查找复杂度为 O(n)；<code>list</code> 的随机访问的时间复杂度为 O(n)，查找复度为 O(n)。</p>
</li>
<li>
<p>修改：<code>vector</code> 的随机访问修改的时间复杂度为 O(1)；<code>list</code> 的随机访问修改的时间复杂度为 O(n)。</p>
<p>因此，在选择 <code>vector</code> 和 <code>list</code> 时，需要根据自己的需求选择。如果需要频繁随机访问，那么 <code>vector</code> 是一个不错的选择；如果需要频繁插入和删除元素，那么 <code>list</code> 是一个不错的选择。</p>
</li>
</ol>
<h4 id="△-88次-简述-vector-的实现原理">△ 88次 简述 <code>vector</code> 的实现原理</h4>
<p><code>vector</code> 是一个线性的动态数组，其实现原理是利用了 C++ 中的内存管理机制：</p>
<ol>
<li>初始化：当创建一个 <code>vector</code> 时，它会预先分配一定数量的内存。</li>
<li>添加元素：当向 <code>vector</code> 中添加元素时，它会检查当前分配的内存是否已满。如果没有满，则将元素直接添加到内存中；如果已满，则分配更多的内存，并将元素添加到新分配的内存中。</li>
<li>访问元素：当访问 <code>vector</code> 中的元素时，可以直接通过下标访问。</li>
<li>删除元素：当删除 <code>vector</code> 中的元素时，可以直接使用 <code>vector</code> 的 erase 函数进行删除，它将删除对应下标的元素并移动其他元素以填补空缺。</li>
<li>释放内存：当 <code>vector</code> 不再使用时，它会自动释放所有分配的内存。</li>
</ol>
<p><code>vector</code> 的实现主要依靠 C++ 中的内存分配和释放机制，并结合了丰富的函数接口，使得它能够灵活地处理动态内存分配和使用问题。</p>
<h4 id="△-87次-C-11-有什么新特性">△ 87次 C++ 11 有什么新特性</h4>
<p>C++11是 C++ 的一个重大更新版本，主要引入了如下新特性：</p>
<ol>
<li><code>Lambda</code> 表达式：C++11 新增了 <code>Lambda</code> 表达式，使得在代码中创建匿名函数更加简单。</li>
<li>右值引用：C++11 引入了右值引用，可以对不同类型的对象进行分类，提高代码效率。</li>
<li>移动语义：C++11 引入了移动语义，可以避免不必要的复制，从而提高代码效率。</li>
<li>智能指针：C++11 新增了 <code>shared_ptr</code> 和 <code>unique_ptr</code> 两种智能指针，可以更好地管理动态内存。</li>
<li>模板元编程：C++11 提供了更为强大的模板元编程功能，可以更好地处理复杂的编程任务。</li>
<li>新增容器：C++11 新增了如 <code>unordered_map</code>、<code>forward_list</code> （单链表）等容器，为程序员提供了更多的选择。</li>
<li>并发编程：C++11 新增了如 <code>std::thread</code>、<code>std::atomic</code> 等并发编程的支持，使得 C++ 可以更好地实现多线程程序。</li>
<li>其他：C++11 还包括了如强制类型转换、列表初始化、类型推导、可变参数模板等特性。</li>
</ol>
<p>C++11 的新特性不仅提高了 C++ 的编程效率，同时也增加了 C++ 的编程灵活性和简洁性。例如，使用 <code>Lambda</code> 表达式可以替代一些繁琐的回调函数；使用右值引用可以实现更高效的对象交换；使用移动语义可以节省复制对象的时间。</p>
<p>此外，C++11 还为 C++ 提供了一种新的多线程编程模式，使得 C++ 可以更好地适应当今多核处理器的硬件环境。</p>
<p>总的来说，C++11 对 C++ 语言进行了重大更新，为程序员提供了更多的工具和方法，使得 C++ 变得更加强大和实用。</p>
<h4 id="△-80次-C-中智能指针和指针的区别是什么？">△ 80次 C++ 中智能指针和指针的区别是什么？</h4>
<p>C++ 中的智能指针和指针有如下不同：</p>
<ol>
<li>内存管理：智能指针是一种封装了指针的对象，具有自动管理内存的功能，无需手动调用 <code>delete</code> 进行内存释放。而普通指针则需要手动进行内存释放，容易造成内存泄漏。</li>
<li>安全性：智能指针<code>shared_ptr</code>在实现时使用了引用计数等技术，保证了其所指向的对象在使用结束后能够被正确地释放。而普通指针在没有特殊处理时是容易产生错误的。</li>
<li>可读性：智能指针的语法比普通指针更加简洁易懂，有利于降低代码的复杂度和提高代码的可读性。</li>
</ol>
<p>总的来说，智能指针是 C++ 中一种优秀的内存管理工具，它不仅方便了内存管理，也提高了代码的安全性和可读性。</p>
<h4 id="△-74次-简述-C-右值引用与转移语义">△ 74次 简述 C++ 右值引用与转移语义</h4>
<p>C++ 中的右值引用和转移语义是 C++11 新引入的一种特殊的引用，它们是对 C++ 的普通引用的一种拓展。</p>
<p>右值引用是一种特殊的引用，它可以引用一个将要被销毁的对象，并且只能引用一次。与普通的左值引用不同，右值引用可以引用临时对象，如表达式的结果、函数返回值等。</p>
<p>转移语义是 C++11 引入的一种语法，可以方便地将一个对象的所有权从一个对象转移到另一个对象。通过使用转移语义，可以避免无用的内存拷贝和内存空间浪费，从而提高代码的效率。</p>
<p>右值引用和转移语义在实际使用中与智能指针等内存管理工具结合使用时可以大大提高代码的效率。</p>
<p>在 C++ 类型设计中，如果需要实现析构函数，就一定要正确地实现拷贝构造器和赋值运算符重载，这被称为三法则，如果再加上移动构造函数和移动赋值运算符重载，称为五法则。</p>
<h4 id="△-68次-C-中多态是怎么实现的">△ 68次 C++ 中多态是怎么实现的</h4>
<p>C++ 中的多态是通过虚函数实现的。</p>
<p>虚函数是一种特殊的函数，允许在派生类中重写基类中的定义。当一个指向基类的指针指向一个派生类对象时，编译器会根据指针所指向的实际对象的类型来调用虚函数。</p>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharpCopy codeclass Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span>()</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shape::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">public</span> <span class="hljs-title">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span>() <span class="hljs-keyword">override</span></span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> : <span class="hljs-title">public</span> <span class="hljs-title">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span>() <span class="hljs-keyword">override</span></span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果我们有一个指向 Shape 的指针，并且它指向一个 Circle 对象，则当我们调用 draw() 函数时，编译器会自动调用 Circle::draw() 函数，而不是 Shape::draw() 函数。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">scssCopy codeShape *s <span class="hljs-operator">=</span> new Circle()<span class="hljs-comment">;</span><br>s-&gt;draw()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">cCopy <span class="hljs-built_in">code</span><br>Circle::<span class="hljs-built_in">draw</span><br></code></pre></td></tr></table></figure>
<p>这就是 C++ 中多态的实现原理，它允许我们通过一个基类指针来访问多个不同的派生类对象，并且在运行时自动调用正确的虚函数。</p>
<h4 id="△-66次-const-static-关键字有什么区别">△ 66次 const, static 关键字有什么区别</h4>
<h4 id="△-40次-简述-C-中内存对齐的使用场景">△ 40次 简述 C++ 中内存对齐的使用场景</h4>
<p>C++ 中的内存对齐是指在程序的运行过程中，将不同类型的变量分配到内存中，保证各个变量在内存中的地址是以固定的大小对齐的。</p>
<p>内存对齐的使用场景主要有两个：</p>
<ol>
<li>提高存取效率：现代 CPU 的存取效率是以字（word）为单位的，因此当变量在内存中对齐时，存取速度会比不对齐时快。</li>
<li>减少内存空间：如果不进行内存对齐，就会有很多内存空间浪费，因此内存对齐能有效地减少内存空间的浪费。</li>
</ol>
<p>在 C++ 中，通过使用关键字 <code>alignas</code> 来实现内存对齐，并通过结构体、类、数组等数据类型的内存布局和编译器的优化来实现内存对齐的目的。</p>
<h4 id="△-38次-指针和引用的区别是什么？">△ 38次 指针和引用的区别是什么？</h4>
<p>C++ 中的指针和引用是两种不同的数据类型，它们的主要区别如下：</p>
<ol>
<li>定义方式：指针是一种独立的数据类型，而引用是一种别名，不能独立存在，必须与一个对象关联。</li>
<li>内存分配：指针可以独立分配内存，而引用必须关联到一个已存在的对象。</li>
<li>修改：指针可以指向任何内存地址，并且可以在运行时动态改变其指向的内存地址，而引用则不能改变关联的对象，也不能改变关联的对象的内存地址。</li>
<li>空值：指针可以为空值，但引用不能为空值。</li>
</ol>
<p>总的来说，指针比较灵活，但容易产生问题，而引用则相对安全，但功能不如指针。因此，在实际使用中，引用主要用于函数传参，指针则用于动态内存分配等场景。</p>
<h4 id="△-32次-C-中解释类模板和模板类的区别">△ 32次 C++ 中解释类模板和模板类的区别</h4>
<h4 id="△-30次-简述-C-的内联函数">△ 30次 简述 C++ 的内联函数</h4>
<p>内联函数是 C++ 中的一种特殊函数，关键字 “inline” 被用于声明它。内联函数与普通函数的主要区别在于，在编译时，内联函数的代码会被直接替换到它的调用处，而不是作为独立函数存在。因此，内联函数的调用比普通函数调用要快，但是它们占用更多的空间。通常情况下，如果函数很短且频繁地调用，内联函数是一个不错的选择。</p>
<h4 id="△-28次-简述-C-编译的过程">△ 28次 简述 C++ 编译的过程</h4>
<p>C++ 的编译过程包括以下几个步骤：</p>
<ol>
<li>预处理：预处理器对源代码进行处理，对于预处理指令（如 #include）的处理，并对宏定义进行替换。</li>
<li>编译：编译器将预处理过的代码编译成汇编语言，检查代码的语法正确性和类型正确性。</li>
<li>汇编：汇编器将汇编代码转换成机器语言。</li>
<li>链接：链接器将被编译的代码和其他已编译的代码，如库函数、系统函数等，链接在一起形成一个可执行文件。</li>
</ol>
<p>最终，编译过程生成了一个可执行文件，该文件可以在计算机上运行，执行用户编写的代码。</p>
<h4 id="△-28次-C-中哪些函数不能被声明为虚函数？">△ 28次 C++ 中哪些函数不能被声明为虚函数？</h4>
<p>以下几种情况的函数不能被声明为虚函数：</p>
<ol>
<li>静态函数：静态函数不受对象的影响，不能被重写。</li>
<li>常量函数：常量函数不能修改对象的状态，因此不能被重写。</li>
<li>内联函数：内联函数是在编译期间展开的，不需要被重写。</li>
<li>构造函数：构造函数不能被重写，因为它们是在对象创建时自动调用的。</li>
<li>普通函数，友元函数。</li>
</ol>
<p>总之，不能声明为虚函数的函数是不能被重写的函数。</p>
<h4 id="△-24次-编译时链接有几种方式？静态链接和动态链接的区别是什么？">△ 24次 编译时链接有几种方式？静态链接和动态链接的区别是什么？</h4>
<p>C++ 编译时链接有两种方式：静态链接和动态链接。</p>
<p>静态链接：在编译的时候，把所有的相关代码和库函数合并到可执行文件中，在程序运行的时候，不需要再从库文件中读取代码，所以执行的速度很快，但是文件体积很大。</p>
<p>动态链接：在编译的时候，仅仅把引用的库函数的地址存储在可执行文件中，在程序运行的时候，再从库文件中读取相关代码，所以执行速度比较慢，但是文件体积很小。</p>
<p>因此，静态链接适合发布程序，而动态链接适合开发和测试。</p>
<h4 id="△-24次-C-是如何进行内存管理的？">△ 24次 C++ 是如何进行内存管理的？</h4>
<p>C++ 通过 <code>new</code> 和 <code>delete</code> 运算符来进行内存管理。在 C++ 中，使用 <code>new</code> 运算符申请内存，使用 <code>delete</code> 运算符释放内存。</p>
<p>当你在程序中使用 <code>new</code> 运算符时，系统将为您分配所需的内存，并返回一个指向该内存块的指针。您可以使用这个指针来访问分配的内存，并在完成使用后释放它。使用 <code>delete</code> 运算符释放内存时，该内存将返回给系统以供后续使用。</p>
<p>此外，C++ 还支持智能指针，这是一种特殊类型的指针，它自动释放分配的内存，并帮助防止内存泄漏。</p>
<h4 id="△-23次-C-的重载和重写是如何实现的？">△ 23次 C++ 的重载和重写是如何实现的？</h4>
<p>C++ 中的重载 (<strong>Overloading</strong>) 和重写 (<strong>Overwriting</strong>) 分别是什么：</p>
<p>重载：重载是指在同一作用域内，为了提高代码的可读性和程序的可维护性，允许同一个函数名称，但是参数列表不同的函数存在。这种方法可以让我们在编写代码时使用相同的函数名，但是函数的具体实现不同。</p>
<p>重写：重写是指在继承关系中，子类重新实现父类的虚函数。重写可以保证在继承关系中，使用父类的指针调用函数时，实际执行的是子类重写后的函数，这样可以使用父类的代码，并对其进行定制。</p>
<p>实现：重载的实现通过根据参数的不同选择正确的函数。重写的实现通过重新实现虚函数，并使用虚表存储函数地址，以实现动态绑定。</p>
<h4 id="△-22次-内存中堆与栈的区别是什么？">△ 22次 内存中堆与栈的区别是什么？</h4>
<p>C++ 中堆和栈是两个不同的内存区域，用于存储不同类型的对象。</p>
<p>栈：栈是一个先进后出的内存结构，是计算机内存中的一块存储区域，主要用于存储程序中定义的函数、方法、变量等。栈内存分配速度快，因为内存管理是编译器在编译时完成的。但栈内存大小是固定的，并且一旦栈内存溢出，程序就会出现运行时错误。</p>
<p>堆：堆是一个动态分配的内存结构，是计算机内存中的一块存储区域，主要用于存储程序中的大对象或动态对象。堆内存分配速度比栈慢，因为内存管理是由程序员在运行时完成的，并且需要使用内存分配函数（如 <code>malloc</code> 和 <code>new</code>）来分配内存。但堆内存大小是动态的，并且可以根据需要动态分配和释放内存，这使得堆内存更灵活。</p>
<p>因此，当需要存储临时变量或本地变量时，使用栈内存是比较理想的选择，因为它们速度快；当需要存储大对象或动态对象时，使用堆内存是更好的选择，因为它们灵活性更高。</p>
<h4 id="△-20次-简述-STL-中的内存分配器原理">△ 20次 简述 STL 中的内存分配器原理</h4>
<p>STL (Standard Template Library) 中的内存分配器是一种用于管理 STL 容器内部数据结构所使用的内存的机制。STL 标准库中的内存分配器被设计成独立的模块，这意味着 STL 容器的使用者可以选择不同的内存分配器来控制 STL 容器的内存分配行为。</p>
<p>STL 中的内存分配器是通过使用 <code>Allocator</code> 类模板来实现的。所有的内存分配器必须遵守 <code>Allocator</code> 接口，并且提供相同的一组配置函数，例如用于分配内存块、回收内存块、管理内存块等。</p>
<p>与其他内存分配器相比，STL 中的内存分配器具有许多优点，例如提供了与 STL 容器紧密结合的内存管理功能，可以大大减少内存碎片，以及提高内存分配的效率。STL 中预定义的内存分配器包括 <code>std::allocator</code>，它是一个简单的内存分配器，可以使用系统的 <code>malloc</code> 和 <code>free</code> 函数来分配和回收内存。此外，还有一些高级的内存分配器，例如 <code>std::pool_allocator</code> 和 <code>std::debug_allocator</code>，可以在不同的应用环境中提供更为专门的内存分配功能。</p>
<p>STL 中的内存分配器是 STL 中的一个组件，主要负责管理内存的分配与释放。内存分配器的原理是使用缓存机制，对于已经分配出去的内存，它会维护一个内存池，再次需要内存时会从内存池中分配，避免了频繁调用 <code>new</code> 和 <code>delete</code> 这样的操作，从而提高了效率。</p>
<p>STL 中的内存分配器默认使用 <code>std::allocator</code> ，也可以使用自定义的内存分配器来替换默认内存分配器。在实现内存分配器时，需要重载一些函数，如 <code>allocate()</code> 和 <code>deallocate()</code>，实现具体的内存分配与释放操作。</p>
<h4 id="△-18次-构造函数和析构函数可以被声明为虚函数吗？">△ 18次 构造函数和析构函数可以被声明为虚函数吗？</h4>
<p><strong>构造函数不能声明为虚函数的原因是:</strong>**<br>
1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。</p>
<p>2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化<code>vptr</code>，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。</p>
<p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？）<br>
编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。</p>
<p>析构函数设为虚函数的作用:<br>
解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。</p>
<h4 id="△-18次-类默认的构造函数是什么？">△ 18次 类默认的构造函数是什么？</h4>
<p>如果一个类没有显式地定义构造函数，那么编译器将为这个类生成一个默认构造函数。默认构造函数没有参数，并且在该类的每个对象被定义时，都将隐式地调用默认构造函数，将该对象的所有数据成员初始化为适当的默认值。</p>
<p>如果一个类显式地定义了构造函数，则不再需要默认构造函数，除非程序员明确请求它。如果程序员需要默认构造函数，他可以显式地定义一个，并在定义的过程中对对象的成员变量进行初始化。</p>
<h4 id="△-18次-lambda-函数的特点，和普通函数相比有什么优点？">△ 18次 <code>lambda</code> 函数的特点，和普通函数相比有什么优点？</h4>
<p>C++ 中的 <code>lambda</code> 函数，也称为匿名函数，是一种简化函数定义的方式。它具有以下特点：</p>
<ol>
<li>可以直接定义在代码中，而不需要单独定义。</li>
<li>可以捕获周围代码块中的变量，这样它可以使用外部的变量和状态。</li>
<li>可以访问父级作用域中的变量，包括函数参数、静态变量和全局变量。</li>
<li>支持自定义返回类型，不需要显式声明。</li>
</ol>
<p>与普通函数相比，<code>lambda</code> 函数具有以下优点：</p>
<ol>
<li>更加简洁，代码可读性更高。</li>
<li>易于编写和维护，因为它不需要命名。</li>
<li>可以直接传递给 STL 容器和函数，而不需要先声明和定义函数。</li>
<li>支持高阶函数编程，可以在函数内进行递归、函数式编程等。</li>
</ol>
<h4 id="△-18次-父类和子类是不是在同一个虚函数表">△ 18次 父类和子类是不是在同一个虚函数表</h4>
<p>不是，每一个类都有自己的虚函数表。当一个类是另一个类的子类时，子类会继承父类的虚函数，但是它们有各自的虚函数表。子类的虚函数表包含父类的虚函数，同时也可以增加子类特有的虚函数。因此，在同一个继承关系中的类并不在同一个虚函数表中，而是各有各自的虚函数表。</p>
<h4 id="△-16次-简述-STL-中的-map-的实现原理">△ 16次 简述 STL 中的 map 的实现原理</h4>
<h4 id="△-16次-简述使用协程的优点">△ 16次 简述使用协程的优点</h4>
<p>协程（Coroutine）是一种轻量级的协作程序，与线程不同，它不需要线程间切换的开销，更适合用于短时间的计算任务。</p>
<p>协程的使用可以让程序员在没有多线程的帮助下实现协作式多任务处理。相比线程，协程的创建和切换更加轻量，因此更适合在需要频繁创建和切换任务的场景中使用。</p>
<p>使用协程的优点：</p>
<ol>
<li>轻量：相比线程，协程的创建和切换代价更小。</li>
<li>简化开发：通过使用协程，可以在单线程中实现多任务处理，简化了程序的结构。</li>
<li>减少上下文切换：相比线程，协程的上下文切换更少，因此更有效地利用 CPU 资源。</li>
<li>简化同步：协程提供了一种简单的方法来实现同步，比线程更加易于管理。</li>
</ol>
<p>总体来说，协程为程序员提供了一种轻量级的方式来实现协作式多任务处理，是一种有效的替代线程的技术。</p>
<h4 id="△-16次-简述-C-的内存分区">△ 16次 简述 C++ 的内存分区</h4>
<p>C++ 中的内存分区是指将整块内存分成不同的区域，用于存储不同类型的数据。常见的内存分区有：</p>
<ol>
<li>栈内存：对于局部变量或方法内部的变量，它们存储在栈内存中。它们是自动分配和释放的，不需要手动管理内存。</li>
<li>堆内存：对于动态分配的内存，它们存储在堆内存中。它们需要手动分配和释放，通过 <code>new</code> 和 <code>delete</code> 操作实现。</li>
<li>全局/静态内存：对于全局变量和静态变量，它们存储在全局/静态内存中。它们在程序启动时分配，程序结束时释放。</li>
<li>常量内存：对于常量，它们存储在常量内存中。它们是只读的，不能被修改。</li>
</ol>
<p>这些内存分区的使用是根据需要不同的内存需求而选择的，比如栈内存用于存储临时变量，堆内存用于存储动态分配的内存，全局/静态内存用于存储程序全局变量，常量内存用于存储常量。</p>
<h4 id="△-14次-C-的-vector-和-list-中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？">△ 14次 C++ 的 <code>vector</code> 和 <code>list</code> 中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</h4>
<p>迭代器和指针之间的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
<p><code>vector</code>和<code>list</code>特性</p>
<p><code>vector</code>特性 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</p>
<p><code>list</code>特性 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p>
<p><code>vector</code>增删元素</p>
<p>对于<code>vector</code>而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p>
<p><code>list</code>增删元素</p>
<p>对于<code>list</code>而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</p>
<h4 id="△-14次-什么是字节对齐，为什么要采用这种机制？">△ 14次 什么是字节对齐，为什么要采用这种机制？</h4>
<p>字节对齐是指内存对齐，是将一段内存的起始地址按照一定的规则对齐，使得数据能够被更高效地访问。</p>
<p>为什么要采用这种机制呢？在计算机系统中，内存访问速度取决于内存地址，如果数据需要从内存中读取，如果数据不在同一个内存页中，则需要从不同的内存页中读取，比较慢。而如果对齐了，数据就可以快速地从内存读取，提高程序性能。因此，字节对齐是很有必要的</p>
<h4 id="△-12次-C-中什么是菱形继承问题？">△ 12次 C++ 中什么是菱形继承问题？</h4>
<p>菱形继承问题是指在 C++ 中，如果两个父类都有一个相同的成员，那么继承这两个父类的子类将存在二义性，无法确定应该继承哪个父类的该成员。这是一个继承体系中需要注意的问题。</p>
<h4 id="△-12次-什么是内存泄漏，怎么确定内存泄漏？">△ 12次 什么是内存泄漏，怎么确定内存泄漏？</h4>
<p>内存泄漏是指程序分配了内存但在未来不再需要这些内存的情况下未能释放已分配的内存空间，从而导致内存不足问题。内存泄漏在长时间运行的程序中可能会导致程序瘫痪，或在不正常终止程序时导致内存泄漏。</p>
<p>可以使用许多工具来检测和诊断内存泄漏，如内存调试工具和内存泄漏检测器。一些常见的内存调试工具有valgrind，Electric Fence，Microsoft Visual C++的debug heap。</p>
<h4 id="△-12次-只定义析构函数，会自动生成哪些构造函数？">△ 12次 只定义析构函数，会自动生成哪些构造函数？</h4>
<p>如果在C++中仅定义了析构函数，那么编译器会自动生成一个默认构造函数。如果你需要使用带有参数的构造函数，则需要显式地定义。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">kotlinCopy codeclass MyClass &#123;<br> <span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，编译器将生成一个默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">cssCopy code</span><br><span class="hljs-function"><span class="hljs-title">MyClass::MyClass</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* default constructor */</span> &#125;<br></code></pre></td></tr></table></figure>
<p>如果需要生成带有参数的构造函数，则需要手动定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">javaCopy codeclass MyClass &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> i) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="△-12次-变量的声明和定义有什么区别？">△ 12次 变量的声明和定义有什么区别？</h4>
<p>在C++中，变量的声明和定义是不同的概念。</p>
<p>声明是指告诉编译器一个变量的名称，类型和作用域。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cCopy code<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;<br></code></pre></td></tr></table></figure>
<p>定义是指分配内存空间并为变量赋初始值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pythonCopy code<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>在C++中，变量可以同时声明和定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pythonCopy code<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>请注意，如果一个变量已经被声明，则不需要再次声明，只需在需要使用该变量的地方定义即可。这是因为声明告诉编译器变量的类型和名称，因此编译器可以在程序的整个作用域中识别该变量。</p>
<h4 id="△-12次-C-C-内存存储区有哪几种类型？">△ 12次 C/C++内存存储区有哪几种类型？</h4>
<p>C++中内存存储区分为以下几种类型：</p>
<ol>
<li>栈（Stack）：存储函数的局部变量，生命周期随着函数的退出而结束。</li>
<li>堆（Heap）：动态分配内存，生命周期由程序员控制，在程序结束时需要手动释放内存。</li>
<li>全局/静态存储区（Global/Static Storage）：存储全局变量和静态局部变量，生命周期始于程序的开始直到程序的结束。</li>
<li>常量存储区（Constant Storage）：存储常量，生命周期始于程序的开始直到程序的结束。</li>
<li>程序代码存储区（Program Code Storage）：存储程序的二进制代码，不能直接读写。</li>
</ol>
<p>请注意，这些存储区的具体实现可能因编译器和操作系统的不同而有所差异。</p>
<h4 id="△-12次-简述程序编译和链接的过程">△ 12次 简述程序编译和链接的过程</h4>
<p>C++程序的编译和链接过程可以大致分为如下几个步骤：</p>
<ol>
<li>编译（Compilation）：将 C++ 源代码编译成机器可以识别的目标代码（通常是汇编代码），一般使用编译器（如 GCC）完成。</li>
<li>汇编（Assembly）：将目标代码编译成机器可执行的代码，一般使用汇编器（Assembler）完成。</li>
<li>链接（Linking）：将由多个目标文件组成的程序链接起来，以形成一个可执行的程序。链接阶段会解决函数和变量在程序中的实际位置，并将程序所需的其他库文件和资源（如图片、字体等）包含进去。</li>
</ol>
<p>通常，编译器和汇编器都是通过命令行界面进行操作，而在开发环境中（如 Visual Studio）则会自动完成这些步骤。</p>
<h4 id="△-10次-简述-C-从代码到可执行二进制文件的过程">△ 10次 简述 C++ 从代码到可执行二进制文件的过程</h4>
<p>C++ 从代码到可执行二进制文件的过程通常包括如下几个步骤：</p>
<ol>
<li>编写代码：使用 C++ 编程语言编写源代码。</li>
<li>编译代码：使用 C++ 编译器（例如 GCC）将源代码编译成目标代码（也称为机器代码）。</li>
<li>汇编代码：使用汇编器将目标代码编译成二进制代码（也称为可重定位目标代码）。</li>
<li>链接代码：使用链接器将二进制代码链接到一起，生成可执行的二进制文件。</li>
<li>运行二进制文件：使用操作系统的加载器将二进制文件加载到内存中，然后通过处理器执行二进制文件中的代码，完成程序的运行。</li>
</ol>
<p>请注意，这些步骤可能因编译器、操作系统和其他工具的不同而有所差异。不同的编译器和开发环境也可以隐藏掉其中一些步骤，例如将编译、汇编和链接等步骤结合在一起。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>interview</div>
      <div>http://yolo-jbc.github.io/2023/02/11/interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jumping</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
