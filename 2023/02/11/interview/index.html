

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jumping">
  <meta name="keywords" content="">
  
    <meta name="description" content="总结C++面试相关问题">
<meta property="og:type" content="article">
<meta property="og:title" content="interview">
<meta property="og:url" content="http://yolo-jbc.github.io/2023/02/11/interview/index.html">
<meta property="og:site_name" content="Jumping&#39;s Blog">
<meta property="og:description" content="总结C++面试相关问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yolo-jbc.github.io/img/Algorithm/graph/search.jpg">
<meta property="article:published_time" content="2023-02-11T04:47:38.000Z">
<meta property="article:modified_time" content="2023-03-08T00:59:22.048Z">
<meta property="article:author" content="Jumping">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yolo-jbc.github.io/img/Algorithm/graph/search.jpg">
  
  
  
  <title>interview - Jumping&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yolo-jbc.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jumping&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="interview"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-11 12:47" pubdate>
          2023年2月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          142 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">interview</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="△-210次-简述-C-中智能指针的特点，简述-new-与-malloc-的区别">△ 210次 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别</h4>
<p>C++ 中的智能指针是一种更高级的内存管理工具，它在 C++11 标准中被引入。智能指针的特点如下：</p>
<p>自动管理内存：智能指针可以自动管理分配的内存，在没有任何引用指向该内存时自动释放内存。</p>
<p>避免内存泄漏：因为智能指针会自动管理内存，所以可以避免内存泄漏的情况。</p>
<p>方便使用：智能指针可以像普通指针一样使用，不需要手动释放内存。</p>
<p>安全性：智能指针可以避免空指针和重复释放内存的错误。</p>
<ol>
<li>
<p><code>uniqued_ptr</code> 作用域指针，指针变量作用域结束自动释放内存。</p>
<p>unique_ptr的实现原理是使用了模板类和移动语义²⁵。unique_ptr类定义了一个指针类型的成员变量，用来存储原始指针，并重载了拷贝构造函数和赋值运算符，使得unique_ptr对象不能被拷贝或赋值，只能被移动²⁵。当unique_ptr对象被移动时，它会将自己的原始指针转移给另一个unique_ptr对象，并将自己的原始指针置为空⁵。当unique_ptr对象销毁时，它会调用自己的删除器（默认是delete）来释放原始指针所指向的内存²⁵。unique无法放在stl容器中，因为对它指向的对象具有唯一的拥有权，不会被共享和转移。这是通过不可拷贝实现的</p>
</li>
<li>
<p><code>shared_ptr</code> 实现的方式取决于编译器和在编译器中使用地标准库。但基本都是引用计数法：引用计数会追踪指针有多少个引用，一旦数量为零就会删除指针所指向的内存空间。shared_ptr实现了拷贝构造函数和赋值运算符，可以存放到stl容器中。同时，也实现了比较运算符，可以存放到关联容器中。</p>
<p>和 <code>unique_ptr</code> 一样由于异常安全的原因而不推荐使用 <code>new</code> 的方式创建智能指针不同，因为 <code>shared_ptr</code> 需要分配另一块内存，称为控制块，用来存储引用计数，所以如果使用 <code>new</code> 的形式来创建一个对象再将其传给 <code>shared_ptr</code> 的构造函数，他就必须做两次内存分配。</p>
</li>
<li>
<p><code>weak_ptr</code> 和复制 <code>shared_ptr</code> 所做的一样，但当你把 <code>shared_ptr</code> 赋值给一个 <code>weak_ptr</code>，假如唯一的那个 <code>shared_ptr</code> 指针死去，内存就会被删除，因为赋值给 <code>weak_ptr</code> 并不会增加引用数量。例如你在排序一个集合，你不需要关注指针是否有效，你只需要存储一个他们的引用就好了。<code>weak_ptr</code>实现了拷贝构造函数、赋值运算符和比较运算符所以可以放入stl容器和关联容器中。</p>
<p><code>shared_ptr</code>和<code>weak_ptr</code>也是C++11提供的智能指针，它们都使用了引用计数的技术来管理对象的生命周期²³。<code>shared_ptr</code>拥有对象和元信息（控制块），而<code>weak_ptr</code>只拥有元信息¹⁴。</p>
<p><code>shared_ptr</code>和<code>weak_ptr</code>都包含一个指向实际对象的指针，和一个指向计数器对象的指针²。计数器对象存储了两个不同的计数：使用计数是指向对象的<code>shared_ptr</code>实例的数量，弱引用计数是指向对象的<code>weak_ptr</code>实例的数量²。</p>
<p>当<code>shared_ptr</code>被拷贝或赋值时，它会增加使用计数；当<code>shared_ptr</code>被销毁时，它会减少使用计数；当使用计数变为零时，它会删除对象和计数器对象²³。<code>weak_ptr</code>不影响使用计数，但可以通过lock()函数来创建一个临时的<code>shared_ptr</code>，如果对象还存在的话³⁴。当弱引用计数变为零时，它也会删除计数器对象²。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Shape</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;created shape &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete shape&quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//智能指针变量e1的生存期到头自动释放堆上的内存</span><br>        unique_ptr&lt;Shape&gt; e1 = <span class="hljs-built_in">make_unique</span>&lt;Shape&gt;(<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>    &#123;<br>        weak_ptr&lt;Shape&gt; e2;<br>        &#123;<br>            shared_ptr&lt;Shape&gt; e3 = <span class="hljs-built_in">make_shared</span>&lt;Shape&gt;(<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//由于e2是weak_ptr所以不会增加e3的引用计数，e3只有一个引用所以e3的生命期结束之后会delete shape2，再输出ok</span><br>            e2 = e3;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// created shape 1</span><br><span class="hljs-comment">// delete shape1</span><br><span class="hljs-comment">// ok</span><br><span class="hljs-comment">// created shape 2</span><br><span class="hljs-comment">// delete shape2</span><br><span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>除了避免循环引用和悬垂指针，<code>weak_ptr</code> 还有一些其他的用途，例如：</p>
<ul>
<li>作为观察者，可以监视 <code>shared_ptr</code> 所指对象的生命周期，当对象被销毁时，<code>weak_ptr</code> 会自动过期¹⁵。</li>
<li>作为缓存，可以暂时存储 <code>shared_ptr</code> 所指对象的引用，当需要时再转换为 <code>shared_ptr</code> ，如果对象已经被释放，则返回空指针¹⁵。</li>
<li>作为回调函数的参数，可以避免在多线程环境中出现 <code>shared_ptr</code> 的竞争问题，也可以避免回调函数延长对象的生命周期⁵。</li>
</ul>
<p><code>weak_ptr</code> 的 <code>lock()</code> 方法是用来获取一个 <code>shared_ptr</code> 对象，它和 <code>weak_ptr</code> 指向同一个资源¹²⁴。如果 <code>weak_ptr</code> 所指的资源还没有被销毁，那么 <code>lock()</code> 方法会返回一个有效的 <code>shared_ptr</code> 对象，并且增加引用计数¹³⁴。如果 <code>weak_ptr</code> 所指的资源已经被销毁，那么 <code>lock()</code> 方法会返回一个空的 <code>shared_ptr</code> 对象¹³⁴。</p>
<p><code>lock()</code> 方法是原子操作，可以保证线程安全¹⁵。在使用 <code>weak_ptr</code> 时，应该先调用 <code>lock()</code> 方法来检查资源是否有效，然后再访问资源⁴⁶。</p>
<p>好的，我可以给你一个简单的例子，来说明 <code>weak_ptr</code> 的 <code>lock()</code> 方法的用法。假设有一个类 A，它有一个成员函数 foo()，我们想要在另一个线程中调用这个函数，但是不确定 A 的对象是否还存在。我们可以使用 <code>weak_ptr</code> 来传递对象的引用，然后在线程中调用 <code>lock()</code> 方法来检查对象是否有效。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;foo()\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(std::weak_ptr&lt;A&gt; wp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sp = wp.<span class="hljs-built_in">lock</span>()) &#123; <span class="hljs-comment">// 转换为 shared_ptr</span><br>        sp-&gt;<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 调用成员函数</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;object is gone\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;A&gt; sp1 = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;(); <span class="hljs-comment">// 创建 shared_ptr</span><br>    std::weak_ptr&lt;A&gt; wp1 = sp1; <span class="hljs-comment">// 创建 weak_ptr</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(bar, wp1)</span></span>; <span class="hljs-comment">// 启动线程</span><br>    t1.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 等待线程结束</span><br><br>    sp1.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 释放 shared_ptr</span><br>    std::weak_ptr&lt;A&gt; wp2 = sp1; <span class="hljs-comment">// 创建 weak_ptr</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(bar, wp2)</span></span>; <span class="hljs-comment">// 启动线程</span><br>    t2.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 等待线程结束</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">foo()<br>object is gone<br></code></pre></td></tr></table></figure>
<p>这个例子说明了 <code>weak_ptr</code> 的 <code>lock()</code> 方法可以在不延长对象生命周期的情况下，安全地访问对象 。</p>
<p>C++ 中的 <code>new</code> 和 C 语言中的 <code>malloc</code> 都是用来动态分配内存的，但是它们有一些不同的地方：</p>
<ol>
<li><code>new</code>是运算符而<code>mallloc</code>是函数</li>
<li>内存初始化： <code>new</code> 可以自动调用构造函数对内存进行初始化，而 <code>malloc</code> 不能调用构造函数。</li>
<li>类型安全性： <code>new</code> 操作是类型安全的，因为它需要指定内存类型；而 <code>malloc</code> 操作则不是类型安全的，因为它返回的是一个通用指针需要通过强制类型转换将<code>void*</code>指针转换成我们需要的类型。。</li>
<li>内存的释放： <code>new</code> 分配的内存需要调用 <code>delete</code> 进行释放，而 <code>malloc</code> 分配的内存需要调用 <code>free</code> 进行释放。</li>
<li>分配失败返回值：<code>new</code>内存分配失败时，会抛出<code>bac_alloc</code>异常，它不会返回NULL；<code>malloc</code>分配内存失败时返回<code>NULL</code>。</li>
<li>是否需要指定内存大小：使用<code>new</code>操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而<code>malloc</code>则需要显式地指出所需内存的尺寸。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;...&#125;<br>A * ptr = <span class="hljs-keyword">new</span> A;<br>A * ptr = (A *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(A)); <span class="hljs-comment">//需要显式指定所需内存大小sizeof(A);</span><br></code></pre></td></tr></table></figure>
<p>总的来说，在 C++ 中使用 <code>new</code> 比使用 <code>malloc</code> 更方便，更安全，而且更易于使用。不过如果不需要调用构造函数，或者希望得到一个通用指针，则可以使用 <code>malloc</code>。</p>
<p>此外，在 C++ 中，最好使用智能指针代替手动管理内存，因为智能指针可以更方便，更安全的管理内存。</p>
<h4 id="△-102次-C-中虚函数与纯虚函数的区别">△ 102次 C++ 中虚函数与纯虚函数的区别</h4>
<p>在 C++ 中，虚函数和纯虚函数是多态的重要实现方式。它们的主要区别如下：</p>
<ol>
<li>虚函数：虚函数是在基类中定义的一种特殊的函数，其子类可以重写它以实现多态。</li>
<li>纯虚函数：纯虚函数是一种特殊的虚函数，它仅在基类中声明，没有任何实现。纯虚函数的作用是让基类成为抽象类，不能创建基类的对象，只能创建其子类对象。其子类必须实现该纯虚函数，否则子类也是一个抽象类。含有纯虚拟函数的类称为抽象类，它不能生成对象；</li>
</ol>
<p>不同的是，虚函数可以被子类重写，而纯虚函数只能被子类重写，不能被实例化。虚函数的作用是实现多态，而纯虚函数的作用是让子类实现某些特定的功能。</p>
<p>总的来说，虚函数是用来实现多态的，含有纯虚函数的类称作抽象类。</p>
<p>虚函数和纯虚函数与虚表有关。</p>
<p>虚表（Virtual Table）是一个指针数组，每个数组元素都指向一个虚函数的地址。每个类的对象都有一个虚指针（Virtual Pointer），该指针指向该类的虚表。</p>
<p>在 C++ 中，当一个虚函数被调用时，编译器会通过该对象的虚指针找到其对应的虚表，然后根据函数在虚表中的位置调用相应的函数。因此，如果一个函数是虚函数，则其实现在运行时才能确定，这就是多态的实现方式。</p>
<p>而纯虚函数是在基类中声明的，其子类必须实现该函数，因此虚表的实现是基于纯虚函数的。</p>
<h6 id="那为什么要有虚表这个东西呢">那为什么要有虚表这个东西呢</h6>
<p>假如有两个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;I am a person&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;I am a man&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person* ptr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">man</span>();<br>	ptr1-&gt;<span class="hljs-built_in">desc</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>C++中类和操作的封装只是对于程序员而言的</strong>。而编译器编译之后其实还是面向过程的代码。编译器帮你给成员函数增加一个额外的类指针参数，运行期间传入对象实际的指针。这段程序的打印结果是<code>I am a man</code>，因为这里没有声明父类desc为虚函数，因此属于静态绑定。<strong>类的数据(成员变量)和操作(成员函数)其实还是分离的</strong>。仅从对象的内存布局来看，只能看到成员变量，看不到成员函数。因为调用哪个函数是编译期间就确定了的，编译期间只能识别父类的desc。</p>
<p>也就是说在含有虚函数的类编译期间，编译器会自动给这种类在起始位置追加一个虚表指针(称之为: vptr) 。vptr指向一个虚表(称之为: vtable 或 vtbl) ，虚表中存储了实际的函数地址。所有虚函数的的调用取的是哪个函数（地址）是在运行期间通过查虚表确定的。虚表在VS中存放在全局数据区（静态区）</p>
<h4 id="△-87次-C-11-有什么新特性">△ 87次 C++ 11 有什么新特性</h4>
<p>C++11是 C++ 的一个重大更新版本，主要引入了如下新特性：</p>
<ol>
<li><code>Lambda</code> 表达式：C++11 新增了 <code>Lambda</code> 表达式，使得在代码中创建匿名函数更加简单。</li>
<li>右值引用：C++11 引入了右值引用，可以对不同类型的对象进行分类，提高代码效率。</li>
<li>移动语义：C++11 引入了移动语义，可以避免不必要的复制，从而提高代码效率。</li>
<li>智能指针：C++11 新增了 <code>shared_ptr</code> 和 <code>unique_ptr</code> 两种智能指针，可以更好地管理动态内存。</li>
<li>模板元编程：C++11 提供了更为强大的模板元编程功能，可以更好地处理复杂的编程任务。</li>
<li>新增容器：C++11 新增了如 <code>unordered_map</code>、<code>forward_list</code> （单链表）等容器，为程序员提供了更多的选择。</li>
<li>并发编程：C++11 新增了如 <code>std::thread</code>、<code>std::atomic</code> 等并发编程的支持，使得 C++ 可以更好地实现多线程程序。</li>
<li>其他：C++11 还包括了如强制类型转换、列表初始化、类型推导、可变参数模板等特性。</li>
</ol>
<p>C++11 的新特性不仅提高了 C++ 的编程效率，同时也增加了 C++ 的编程灵活性和简洁性。例如，使用 <code>Lambda</code> 表达式可以替代一些繁琐的回调函数；使用右值引用可以实现更高效的对象交换；使用移动语义可以节省复制对象的时间。</p>
<p>此外，C++11 还为 C++ 提供了一种新的多线程编程模式，使得 C++ 可以更好地适应当今多核处理器的硬件环境。</p>
<p>总的来说，C++11 对 C++ 语言进行了重大更新，为程序员提供了更多的工具和方法，使得 C++ 变得更加强大和实用。</p>
<h4 id="△-80次-C-中智能指针和指针的区别是什么？">△ 80次 C++ 中智能指针和指针的区别是什么？</h4>
<p>C++ 中的智能指针和指针有如下不同：</p>
<ol>
<li>内存管理：智能指针是一种封装了指针的对象，具有自动管理内存的功能，无需手动调用 <code>delete</code> 进行内存释放。而普通指针则需要手动进行内存释放，容易造成内存泄漏。</li>
<li>安全性：智能指针<code>shared_ptr</code>在实现时使用了引用计数等技术，保证了其所指向的对象在使用结束后能够被正确地释放。而普通指针在没有特殊处理时是容易产生错误的。</li>
<li>可读性：智能指针的语法比普通指针更加简洁易懂，有利于降低代码的复杂度和提高代码的可读性。</li>
</ol>
<p>总的来说，智能指针是 C++ 中一种优秀的内存管理工具，它不仅方便了内存管理，也提高了代码的安全性和可读性。</p>
<h4 id="△-74次-简述-C-右值引用与转移语义">△ 74次 简述 C++ 右值引用与转移语义</h4>
<p>C++ 中的右值引用和转移语义是 C++11 新引入的一种特殊的引用，它们是对 C++ 的普通引用的一种拓展。</p>
<p>右值引用是一种特殊的引用，它可以引用一个将要被销毁的对象，并且只能引用一次。与普通的左值引用不同，右值引用可以引用临时对象，如表达式的结果、函数返回值等。</p>
<p>转移语义是 C++11 引入的一种语法，可以方便地将一个对象的所有权从一个对象转移到另一个对象。通过使用转移语义，可以避免无用的内存拷贝和内存空间浪费，从而提高代码的效率。</p>
<p>右值引用和转移语义在实际使用中与智能指针等内存管理工具结合使用时可以大大提高代码的效率。</p>
<p>在 C++ 类型设计中，如果需要实现析构函数，就一定要正确地实现拷贝构造器和赋值运算符重载，这被称为三法则，如果再加上移动构造函数和移动赋值运算符重载，称为五法则。</p>
<p>左值和右值是C++中两种不同的表达式的值类别⁴。左值是指可以出现在赋值运算符左边的表达式，它们有确定的存储空间和变量名，可以被修改¹²³。右值是指只能出现在赋值运算符右边的表达式，它们通常是临时的、不可寻址的、不可修改的¹²³。</p>
<p>例如，下面这段代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//a是一个左值，10是一个右值</span><br><span class="hljs-type">int</span> b = a + <span class="hljs-number">5</span>; <span class="hljs-comment">//b是一个左值，a + 5是一个右值</span><br>a = b; <span class="hljs-comment">//a和b都是左值</span><br></code></pre></td></tr></table></figure>
<p>左值引用和右值引用是C++11引入的两种新类型的引用²。左值引用就是我们平常说的引用，它绑定到一个对象上，并且可以通过引用修改对象²³。右值引用就是必须绑定到右值的引用，它可以延长右值的生命周期，并且可以实现移动语义和完美转发²³。</p>
<p>例如，下面这段代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">//x是一个左值</span><br><span class="hljs-type">int</span>&amp; r1 = x; <span class="hljs-comment">//r1是一个左值引用，绑定到x上</span><br>r1 = <span class="hljs-number">20</span>; <span class="hljs-comment">//通过r1修改x</span><br><br><span class="hljs-type">int</span>&amp;&amp; r2 = x + <span class="hljs-number">5</span>; <span class="hljs-comment">//r2是一个右值引用，绑定到x + 5上</span><br><span class="hljs-comment">//r2 = 30; //错误，不能通过r2修改x + 5</span><br><br><span class="hljs-function">std::string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>; <span class="hljs-comment">//s1是一个左值</span><br><span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(std::move(s1))</span></span>; <span class="hljs-comment">//s2使用移动构造函数从s1移动内容，s1变为空字符串</span><br>std::cout &lt;&lt; s1 &lt;&lt; std::endl; <span class="hljs-comment">//&quot;&quot;</span><br>std::cout &lt;&lt; s2 &lt;&lt; std::endl; <span class="hljs-comment">//&quot;hello&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="△-68次-C-中多态是怎么实现的">△ 68次 C++ 中多态是怎么实现的</h4>
<p>C++ 中的多态是通过虚函数实现的。</p>
<p>虚函数是一种特殊的函数，允许在派生类中重写基类中的定义。当一个指向基类的指针指向一个派生类对象时，编译器会根据指针所指向的实际对象的类型来调用虚函数。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">csharpCopy codeclass Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shape::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果我们有一个指向 Shape 的指针，并且它指向一个 Circle 对象，则当我们调用 draw() 函数时，编译器会自动调用 Circle::draw() 函数，而不是 Shape::draw() 函数。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">scssCopy codeShape *s <span class="hljs-operator">=</span> new Circle()<span class="hljs-comment">;</span><br>s-&gt;draw()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">cCopy <span class="hljs-built_in">code</span><br>Circle::<span class="hljs-built_in">draw</span><br></code></pre></td></tr></table></figure>
<p>这就是 C++ 中多态的实现原理，它允许我们通过一个基类指针来访问多个不同的派生类对象，并且在运行时自动调用正确的虚函数。</p>
<h4 id="△-66次-const-static-关键字有什么区别">△ 66次 const, static 关键字有什么区别</h4>
<p>const关键字表示一个值是常量，不能被修改。static关键字表示一个变量或函数的生命周期是整个程序的执行过程，并且只在程序启动前初始化一次。12</p>
<p>这两个概念不是互斥的，可以一起使用。例如，你可以定义一个const static变量，表示它是一个不可变的静态变量。</p>
<p>在全局或命名空间级别，const表示一个变量是常量，不能被修改。static表示一个变量或函数的生命周期是整个程序的执行过程，并且只在程序启动前初始化一次，而且只能在当前文件中访问。在C++中，全局或命名空间级别的const变量默认是static的，除非用extern显式声明。</p>
<p>在函数内部，const表示一个变量是常量，不能被修改。static表示一个变量在函数调用之间保持其值不变，并且只初始化一次。</p>
<p>在类内部，const表示一个成员变量或成员函数不会修改类的状态。static表示一个成员变量或成员函数属于类本身而不是类的对象，并且可以在没有对象的情况下访问。</p>
<h4 id="△-40次-简述-C-中内存对齐的使用场景">△ 40次 简述 C++ 中内存对齐的使用场景</h4>
<p>C++ 中的内存对齐是指在程序的运行过程中，将不同类型的变量分配到内存中，保证各个变量在内存中的地址是以固定的大小对齐的。</p>
<p>内存对齐的使用场景主要有两个：</p>
<ol>
<li>提高存取效率：现代 CPU 的存取效率是以字（word）为单位的，因此当变量在内存中对齐时，存取速度会比不对齐时快。</li>
<li>减少内存空间：如果不进行内存对齐，就会有很多内存空间浪费，因此内存对齐能有效地减少内存空间的浪费。</li>
</ol>
<p>在 C++ 中，通过使用关键字 <code>alignas</code> 来实现内存对齐，并通过结构体、类、数组等数据类型的内存布局和编译器的优化来实现内存对齐的目的。</p>
<h4 id="△-38次-指针和引用的区别是什么？">△ 38次 指针和引用的区别是什么？</h4>
<p>C++ 中的指针和引用是两种不同的数据类型，它们的主要区别如下：</p>
<ol>
<li>定义方式：指针是一种独立的数据类型，而引用是一种别名，不能独立存在，必须与一个对象关联。</li>
<li>内存分配：指针可以独立分配内存，而引用必须关联到一个已存在的对象。</li>
<li>修改：指针可以指向任何内存地址，并且可以在运行时动态改变其指向的内存地址，而引用则不能改变关联的对象，也不能改变关联的对象的内存地址。</li>
<li>空值：指针可以为空值，但引用不能为空值。</li>
</ol>
<p>总的来说，指针比较灵活，但容易产生问题，而引用则相对安全，但功能不如指针。因此，在实际使用中，引用主要用于函数传参，指针则用于动态内存分配等场景。</p>
<h4 id="△-32次-C-中解释类模板和模板类的区别">△ 32次 C++ 中解释类模板和模板类的区别</h4>
<h4 id="△-30次-简述-C-的内联函数">△ 30次 简述 C++ 的内联函数</h4>
<p>内联函数是 C++ 中的一种特殊函数，关键字 “inline” 被用于声明它。内联函数与普通函数的主要区别在于，在编译时，内联函数的代码会被直接替换到它的调用处，而不是作为独立函数存在。因此，内联函数的调用比普通函数调用要快，但是它们占用更多的空间。通常情况下，如果函数很短且频繁地调用，内联函数是一个不错的选择。</p>
<ol>
<li>函数体非常小：如果函数体非常小，那么将函数调用替换为函数体内的代码可以减少函数调用的开销，从而提高程序性能。</li>
<li>函数被频繁调用：如果一个函数被频繁调用，那么将函数调用替换为函数体内的代码可以减少函数调用的开销，从而提高程序性能。</li>
<li>函数中只有简单的表达式或语句：如果一个函数中只包含简单的表达式或语句，那么将函数调用替换为函数体内的代码可以减少函数调用的开销，从而提高程序性能。</li>
</ol>
<h4 id="△-28次-简述-C-编译的过程">△ 28次 简述 C++ 编译的过程</h4>
<p>C++ 的编译过程包括以下几个步骤：</p>
<ol>
<li>预处理：预处理器对源代码进行处理，对于预处理指令（如 #include）的处理，并对宏定义进行替换。</li>
<li>编译：编译器将预处理过的代码编译成汇编语言，检查代码的语法正确性和类型正确性。</li>
<li>汇编：汇编器将汇编代码转换成机器语言。</li>
<li>链接：链接器将被编译的代码和其他已编译的代码，如库函数、系统函数等，链接在一起形成一个可执行文件。</li>
</ol>
<p>最终，编译过程生成了一个可执行文件，该文件可以在计算机上运行，执行用户编写的代码。</p>
<h4 id="△-28次-C-中哪些函数不能被声明为虚函数？">△ 28次 C++ 中哪些函数不能被声明为虚函数？</h4>
<p>以下几种情况的函数不能被声明为虚函数：</p>
<ol>
<li>静态函数：静态函数不受对象的影响，不能被重写。</li>
<li>常量函数：常量函数不能修改对象的状态，因此不能被重写。</li>
<li>内联函数：内联函数是在编译期间展开的，不需要被重写。</li>
<li>构造函数：构造函数不能被重写，因为它们是在对象创建时自动调用的。</li>
<li>普通函数，友元函数。</li>
</ol>
<p>总之，不能声明为虚函数的函数是不能被重写的函数。</p>
<h4 id="△-24次-编译时链接有几种方式？静态链接和动态链接的区别是什么？">△ 24次 编译时链接有几种方式？静态链接和动态链接的区别是什么？</h4>
<p>C++ 编译时链接有两种方式：静态链接和动态链接。</p>
<p>静态链接：在编译的时候，把所有的相关代码和库函数合并到可执行文件中，在程序运行的时候，不需要再从库文件中读取代码，所以执行的速度很快，但是文件体积很大。</p>
<p>动态链接：在编译的时候，仅仅把引用的库函数的地址存储在可执行文件中，在程序运行的时候，再从库文件中读取相关代码，所以执行速度比较慢，但是文件体积很小。</p>
<p>因此，静态链接适合发布程序，而动态链接适合开发和测试。</p>
<h4 id="△-24次-C-是如何进行内存管理的？">△ 24次 C++ 是如何进行内存管理的？</h4>
<p>C++ 通过 <code>new</code> 和 <code>delete</code> 运算符来进行内存管理。在 C++ 中，使用 <code>new</code> 运算符申请内存，使用 <code>delete</code> 运算符释放内存。</p>
<p>当你在程序中使用 <code>new</code> 运算符时，系统将为您分配所需的内存，并返回一个指向该内存块的指针。您可以使用这个指针来访问分配的内存，并在完成使用后释放它。使用 <code>delete</code> 运算符释放内存时，该内存将返回给系统以供后续使用。</p>
<p>此外，C++ 还支持智能指针，这是一种特殊类型的指针，它自动释放分配的内存，并帮助防止内存泄漏。</p>
<h4 id="△-23次-C-的重载和重写是如何实现的？">△ 23次 C++ 的重载和重写是如何实现的？</h4>
<p>C++ 中的重载 (<strong>Overloading</strong>) 和重写 (<strong>Overwriting</strong>) 分别是什么：</p>
<p>重载：重载是指在同一作用域内，为了提高代码的可读性和程序的可维护性，允许同一个函数名称，但是参数列表不同的函数存在。这种方法可以让我们在编写代码时使用相同的函数名，但是函数的具体实现不同。</p>
<p>重写：重写是指在继承关系中，子类重新实现父类的虚函数。重写可以保证在继承关系中，使用父类的指针调用函数时，实际执行的是子类重写后的函数，这样可以使用父类的代码，并对其进行定制。</p>
<p>实现：重载的实现通过根据参数的不同选择正确的函数。重写的实现通过重新实现虚函数，并使用虚表存储函数地址，以实现动态绑定。</p>
<h4 id="△-22次-内存中堆与栈的区别是什么？">△ 22次 内存中堆与栈的区别是什么？</h4>
<p>C++ 中堆和栈是两个不同的内存区域，用于存储不同类型的对象。</p>
<p>栈：栈是一个先进后出的内存结构，是计算机内存中的一块存储区域，主要用于存储程序中定义的函数、方法、变量等。栈内存分配速度快，因为内存管理是编译器在编译时完成的。但栈内存大小是固定的，并且一旦栈内存溢出，程序就会出现运行时错误。</p>
<p>堆：堆是一个动态分配的内存结构，是计算机内存中的一块存储区域，主要用于存储程序中的大对象或动态对象。堆内存分配速度比栈慢，因为内存管理是由程序员在运行时完成的，并且需要使用内存分配函数（如 <code>malloc</code> 和 <code>new</code>）来分配内存。但堆内存大小是动态的，并且可以根据需要动态分配和释放内存，这使得堆内存更灵活。</p>
<p>因此，当需要存储临时变量或本地变量时，使用栈内存是比较理想的选择，因为它们速度快；当需要存储大对象或动态对象时，使用堆内存是更好的选择，因为它们灵活性更高。</p>
<h4 id="△-18次-构造函数和析构函数可以被声明为虚函数吗？">△ 18次 构造函数和析构函数可以被声明为虚函数吗？</h4>
<p><strong>构造函数不能声明为虚函数的原因是:</strong>**<br>
1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。</p>
<p>2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化<code>vptr</code>，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。</p>
<p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？）<br>
编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。</p>
<p>析构函数设为虚函数的作用:<br>
解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。</p>
<h4 id="△-18次-类默认的构造函数是什么？">△ 18次 类默认的构造函数是什么？</h4>
<p>如果一个类没有显式地定义构造函数，那么编译器将为这个类生成一个默认构造函数。默认构造函数没有参数，并且在该类的每个对象被定义时，都将隐式地调用默认构造函数，将该对象的所有数据成员初始化为适当的默认值。</p>
<p>如果一个类显式地定义了构造函数，则不再需要默认构造函数，除非程序员明确请求它。如果程序员需要默认构造函数，他可以显式地定义一个，并在定义的过程中对对象的成员变量进行初始化。</p>
<h4 id="△-18次-lambda-函数的特点，和普通函数相比有什么优点？">△ 18次 <code>lambda</code> 函数的特点，和普通函数相比有什么优点？</h4>
<p>C++ 中的 <code>lambda</code> 函数，也称为匿名函数，是一种简化函数定义的方式。它具有以下特点：</p>
<ol>
<li>可以直接定义在代码中，而不需要单独定义。</li>
<li>可以捕获周围代码块中的变量，这样它可以使用外部的变量和状态。</li>
<li>可以访问父级作用域中的变量，包括函数参数、静态变量和全局变量。</li>
<li>支持自定义返回类型，不需要显式声明。</li>
</ol>
<p>与普通函数相比，<code>lambda</code> 函数具有以下优点：</p>
<ol>
<li>更加简洁，代码可读性更高。</li>
<li>易于编写和维护，因为它不需要命名。</li>
<li>可以直接传递给 STL 容器和函数，而不需要先声明和定义函数。</li>
<li>支持高阶函数编程，可以在函数内进行递归、函数式编程等。</li>
</ol>
<h4 id="△-18次-父类和子类是不是在同一个虚函数表">△ 18次 父类和子类是不是在同一个虚函数表</h4>
<p>不是，每一个类都有自己的虚函数表。当一个类是另一个类的子类时，子类会继承父类的虚函数，但是它们有各自的虚函数表。子类的虚函数表包含父类的虚函数，同时也可以增加子类特有的虚函数。因此，在同一个继承关系中的类并不在同一个虚函数表中，而是各有各自的虚函数表。</p>
<h4 id="△-16次-简述-STL-中的-map-的实现原理">△ 16次 简述 STL 中的 map 的实现原理</h4>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</p>
<h4 id="△-16次-简述使用协程的优点">△ 16次 简述使用协程的优点</h4>
<p>协程（Coroutine）是一种轻量级的协作程序，与线程不同，它不需要线程间切换的开销，更适合用于短时间的计算任务。</p>
<p>协程的使用可以让程序员在没有多线程的帮助下实现协作式多任务处理。相比线程，协程的创建和切换更加轻量，因此更适合在需要频繁创建和切换任务的场景中使用。</p>
<p>使用协程的优点：</p>
<ol>
<li>轻量：相比线程，协程的创建和切换代价更小。</li>
<li>简化开发：通过使用协程，可以在单线程中实现多任务处理，简化了程序的结构。</li>
<li>减少上下文切换：相比线程，协程的上下文切换更少，因此更有效地利用 CPU 资源。</li>
<li>简化同步：协程提供了一种简单的方法来实现同步，比线程更加易于管理。</li>
</ol>
<p>总体来说，协程为程序员提供了一种轻量级的方式来实现协作式多任务处理，是一种有效的替代线程的技术。</p>
<h4 id="△-16次-简述-C-的内存分区">△ 16次 简述 C++ 的内存分区</h4>
<p>C++ 中的内存分区是指将整块内存分成不同的区域，用于存储不同类型的数据。常见的内存分区有：</p>
<ol>
<li>栈内存：对于局部变量或方法内部的变量，它们存储在栈内存中。它们是自动分配和释放的，不需要手动管理内存。</li>
<li>堆内存：对于动态分配的内存，它们存储在堆内存中。它们需要手动分配和释放，通过 <code>new</code> 和 <code>delete</code> 操作实现。</li>
<li>全局/静态内存：对于全局变量和静态变量，它们存储在全局/静态内存中。它们在程序启动时分配，程序结束时释放。</li>
<li>常量内存：对于常量，它们存储在常量内存中。它们是只读的，不能被修改。</li>
</ol>
<p>这些内存分区的使用是根据需要不同的内存需求而选择的，比如栈内存用于存储临时变量，堆内存用于存储动态分配的内存，全局/静态内存用于存储程序全局变量，常量内存用于存储常量。</p>
<h4 id="△-14次-什么是字节对齐，为什么要采用这种机制？">△ 14次 什么是字节对齐，为什么要采用这种机制？</h4>
<p>字节对齐是指内存对齐，是将一段内存的起始地址按照一定的规则对齐，使得数据能够被更高效地访问。</p>
<p>为什么要采用这种机制呢？在计算机系统中，内存访问速度取决于内存地址，如果数据需要从内存中读取，如果数据不在同一个内存页中，则需要从不同的内存页中读取，比较慢。而如果对齐了，数据就可以快速地从内存读取，提高程序性能。因此，字节对齐是很有必要的</p>
<h4 id="△-12次-C-中什么是菱形继承问题？">△ 12次 C++ 中什么是菱形继承问题？</h4>
<p>菱形继承问题是指在 C++ 中，如果两个父类都有一个相同的成员，那么继承这两个父类的子类将存在二义性，无法确定应该继承哪个父类的该成员。这是一个继承体系中需要注意的问题。</p>
<h4 id="△-12次-什么是内存泄漏，怎么确定内存泄漏？">△ 12次 什么是内存泄漏，怎么确定内存泄漏？</h4>
<p>内存泄漏是指程序分配了内存但在未来不再需要这些内存的情况下未能释放已分配的内存空间，从而导致内存不足问题。内存泄漏在长时间运行的程序中可能会导致程序瘫痪，或在不正常终止程序时导致内存泄漏。</p>
<p>可以使用许多工具来检测和诊断内存泄漏，如内存调试工具和内存泄漏检测器。一些常见的内存调试工具有valgrind，Electric Fence，Microsoft Visual C++的debug heap。</p>
<h4 id="△-12次-只定义析构函数，会自动生成哪些构造函数？">△ 12次 只定义析构函数，会自动生成哪些构造函数？</h4>
<p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p>
<p>默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
<p>赋值构造函数默认实现的是值拷贝（浅拷贝）。</p>
<p>所以说，如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和拷贝赋值函数。</p>
<h4 id="△-12次-变量的声明和定义有什么区别？">△ 12次 变量的声明和定义有什么区别？</h4>
<p>在C++中，变量的声明和定义是不同的概念。</p>
<p>声明是指告诉编译器一个变量的名称，类型和作用域。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cCopy code<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;<br></code></pre></td></tr></table></figure>
<p>定义是指分配内存空间并为变量赋初始值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pythonCopy code<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>在C++中，变量可以同时声明和定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pythonCopy code<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>请注意，如果一个变量已经被声明，则不需要再次声明，只需在需要使用该变量的地方定义即可。这是因为声明告诉编译器变量的类型和名称，因此编译器可以在程序的整个作用域中识别该变量。</p>
<h4 id="△-12次-C-C-内存存储区有哪几种类型？">△ 12次 C/C++内存存储区有哪几种类型？</h4>
<p>C++中内存存储区分为以下几种类型：</p>
<ol>
<li>栈（Stack）：存储函数的局部变量，生命周期随着函数的退出而结束。</li>
<li>堆（Heap）：动态分配内存，生命周期由程序员控制，在程序结束时需要手动释放内存。</li>
<li>全局/静态存储区（Global/Static Storage）：存储全局变量和静态局部变量，生命周期始于程序的开始直到程序的结束。</li>
<li>常量存储区（Constant Storage）：存储常量，生命周期始于程序的开始直到程序的结束。</li>
<li>程序代码存储区（Program Code Storage）：存储程序的二进制代码，不能直接读写。</li>
</ol>
<p>请注意，这些存储区的具体实现可能因编译器和操作系统的不同而有所差异。</p>
<h4 id="△-12次-简述程序编译和链接的过程">△ 12次 简述程序编译和链接的过程</h4>
<p>C++程序的编译和链接过程可以大致分为如下几个步骤：</p>
<ol>
<li>编译（Compilation）：将 C++ 源代码编译成机器可以识别的目标代码（通常是汇编代码），一般使用编译器（如 GCC）完成。</li>
<li>汇编（Assembly）：将目标代码编译成机器可执行的代码，一般使用汇编器（Assembler）完成。</li>
<li>链接（Linking）：将由多个目标文件组成的程序链接起来，以形成一个可执行的程序。链接阶段会解决函数和变量在程序中的实际位置，并将程序所需的其他库文件和资源（如图片、字体等）包含进去。</li>
</ol>
<p>通常，编译器和汇编器都是通过命令行界面进行操作，而在开发环境中（如 Visual Studio）则会自动完成这些步骤。</p>
<h4 id="△-10次-简述-C-从代码到可执行二进制文件的过程">△ 10次 简述 C++ 从代码到可执行二进制文件的过程</h4>
<p>C++ 从代码到可执行二进制文件的过程通常包括如下几个步骤：</p>
<ol>
<li>编写代码：使用 C++ 编程语言编写源代码。</li>
<li>编译代码：使用 C++ 编译器（例如 GCC）将源代码编译成目标代码（也称为机器代码）。</li>
<li>汇编代码：使用汇编器将目标代码编译成二进制代码（也称为可重定位目标代码）。</li>
<li>链接代码：使用链接器将二进制代码链接到一起，生成可执行的二进制文件。</li>
<li>运行二进制文件：使用操作系统的加载器将二进制文件加载到内存中，然后通过处理器执行二进制文件中的代码，完成程序的运行。</li>
</ol>
<p>请注意，这些步骤可能因编译器、操作系统和其他工具的不同而有所差异。不同的编译器和开发环境也可以隐藏掉其中一些步骤，例如将编译、汇编和链接等步骤结合在一起。</p>
<h4 id="函数模板的底层原理">函数模板的底层原理</h4>
<p>C++函数模板的底层原理是：</p>
<p>函数模板是一种通用的函数定义，它使用一个虚拟的类型来代表不同的实际类型。<br>
当编译器遇到一个函数模板调用时，它会根据实参的类型来推导出模板参数的类型，并且用实际类型替换虚拟类型，从而生成一个特定版本的函数。<br>
编译器会对函数模板进行两次编译：第一次在声明位置对模板代码进行语法检查；第二次在调用位置对替换后的代码进行语义检查和代码生成。<br>
函数模板可以像普通函数一样被重载，也可以和普通函数同时存在。编译器会优先考虑普通函数，除非函数模板可以产生一个更好的匹配。</p>
<h4 id="lambda函数的底层原理">lambda函数的底层原理</h4>
<p>lambda函数是一种匿名的内联函数，它可以捕获外部变量，并且可以作为参数传递给其他函数。<br>
当编译器遇到一个lambda表达式时，它会将其转换为一个未命名的类的未命名对象，该类含有一个重载的operator()。<br>
lambda表达式的捕获列表决定了该类的数据成员和构造函数，以及是否为const类型。<br>
lambda表达式的返回类型可以省略，编译器会根据返回语句推导出返回类型。</p>
<h4 id="只在堆或者栈上创建对象">只在堆或者栈上创建对象</h4>
<p>思路1：<br>
①构造函数私有化:由于在栈上创建对象需要直接调用其构造函数，所以我们可以将其构造函数私有化，无法在类外部访问，即无法在栈上创建对象。还必须将拷贝构造私有化, 不然会出现用堆上创建好的对象拷贝构造一个栈上的对象这种情况发生。<br>
②由于创建对象要调用构造函数, 在我们不定义其他构造函数时, 我们已经将两个默认构造函数私有, 在类外肯定是调用不到构造函数的。 我们只有定义一个公有的静态成员函数 ,在类内部用new在堆区创建对象并返回其指针。（在静态成员函数中用new 创建对象时, 也会调用构造函数。但静态成员函数不能调用成员函数, 那么new是如何调用构造函数的呢? 这得从静态成员函数为什么不能访问成员函数说起, 每一个非静态成员函数都有一个隐含的this指针, 访问成员变量实际上时通过this指针调用的, 而在构造函数调用前还没有实例化出对象, 也就不需要用this指针去访问。所以构造函数不需要this指针调用, 静态成员函数也就可以调用构造函数了。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> b;<br>	<span class="hljs-comment">//公有的静态成员函数 类内部用new在堆区创建对象并返回其指针</span><br>	<span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">newT</span><span class="hljs-params">(<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(val);<br>	&#125;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-built_in">T</span>(<span class="hljs-type">int</span> val) :<span class="hljs-built_in">b</span>(val)<span class="hljs-comment">//构造函数私有化</span><br>	&#123;&#125;<br>	<span class="hljs-built_in">T</span>(T&amp; x) :<span class="hljs-built_in">b</span>(x.b)<span class="hljs-comment">//拷贝构造函数私有化</span><br>	&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	T&amp; t1 = T::<span class="hljs-built_in">newT</span>(<span class="hljs-number">10</span>);<br>	cout &lt;&lt; t1.b &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路2：<br>
将析构函数私有化 在栈上也就不能直接创建对象了, 因为编译器在编译时会进行检测, 那没有析构函数也是不行的, 我们还需要实现一个函数来调用私有的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>	~<span class="hljs-built_in">T2</span>() <span class="hljs-comment">//析构函数私有化</span><br>	&#123;<br> 		<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> b;<br>	<span class="hljs-built_in">T2</span>(<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>) :<span class="hljs-built_in">b</span>(val) <br>	&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rundestructor</span><span class="hljs-params">()</span> <span class="hljs-comment">//实现一个函数来调用私有的析构函数。</span></span><br><span class="hljs-function">	</span>&#123;<br>       <span class="hljs-keyword">this</span>-&gt;~<span class="hljs-built_in">T2</span>();<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	T2* t2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T2</span>(<span class="hljs-number">10</span>);<br>	cout &lt;&lt; t2-&gt;b &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++中在<strong>堆</strong>上创建对象要用到new ,我们可以直接在这个类内部将new重载成一个私有的成员函数, 目的就是让在类外使用不到原来的操作符new, 这样在类外就无法在堆上创建对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> val)</span> </span><br><span class="hljs-function">	</span>&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-built_in">T3</span>(<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(val) <br>	&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>	T3 a;<br>	cout &lt;&lt; a.a &lt;&lt; endl;<br>	<span class="hljs-function">T3 <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>	cout &lt;&lt; b.a &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>interview</div>
      <div>http://yolo-jbc.github.io/2023/02/11/interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jumping</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
