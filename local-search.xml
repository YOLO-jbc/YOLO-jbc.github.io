<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大数运算</title>
    <link href="/2023/03/17/old/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2023/03/17/old/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="大数加法">大数加法</h2><p><a href="https://leetcode.cn/problems/add-strings/">415.字符串相加</a></p><p>给定两个字符串形式的非负整数 <code>num1</code> 和 <code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>示例 1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;123&quot;</span><br>输出：<span class="hljs-string">&quot;134&quot;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入：num1 = <span class="hljs-string">&quot;456&quot;</span>, num2 = <span class="hljs-string">&quot;77&quot;</span><br>输出：<span class="hljs-string">&quot;533&quot;</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>大数的加法需要模仿列竖式加法，关键是要存储好进位。最开始我陷入了两个<code>string</code>相加到底是几位分情况讨论的困境，其实最后只要确定仍然有进位就往前走一位就可以了。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-comment">//从每个字符串的末尾，也就是数字的个位开始遍历。</span><br>        <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, j = num2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//当前位及之前位的进位</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>||j&gt;=<span class="hljs-number">0</span>||cur!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur+=num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur+=num2[j--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> temp = cur%<span class="hljs-number">10</span>;<br>            ans+=<span class="hljs-built_in">to_string</span>(temp);<br>            cur /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="大数乘法">大数乘法</h2><p>搞清楚索引关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l1 = num1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l2 = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(l1+l2, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l1<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l2<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-type">int</span> tmp = (res[i+j+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)*(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                res[i+j+<span class="hljs-number">1</span>] = tmp%<span class="hljs-number">10</span> +<span class="hljs-string">&#x27;0&#x27;</span>;<br>                res[i+j] += tmp/<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l1+l2; i++)&#123;<br>            <span class="hljs-keyword">if</span>(res[i]!=<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序小结</title>
    <link href="/2023/03/12/old/%E6%8E%92%E5%BA%8F%E5%B0%8F%E7%BB%93/"/>
    <url>/2023/03/12/old/%E6%8E%92%E5%BA%8F%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><ol><li>用了三数中止来优化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 交换两个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">// 对一个子数组进行划分，并返回基准元素的索引</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 选择第一个元素作为基准</span><br>    <span class="hljs-comment">// int pivot = arr[low];</span><br>    <span class="hljs-comment">// 优化三数取中作为基准</span><br>    <span class="hljs-type">int</span> m = low + (high - low) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (arr[low] &gt; arr[high])<br>        <span class="hljs-comment">// 左右保证左端小</span><br>        <span class="hljs-built_in">swap</span>(arr[low], arr[high]);<br>    <span class="hljs-keyword">if</span> (arr[m] &gt; arr[high])<br>        <span class="hljs-comment">// 中右保证中间小</span><br>        <span class="hljs-built_in">swap</span>(arr[m], arr[high]);<br>    <span class="hljs-keyword">if</span> (arr[m] &gt; arr[low])<br>        <span class="hljs-comment">// 左中保证中间小</span><br>        <span class="hljs-built_in">swap</span>(arr[m], arr[low]);<br>    <span class="hljs-comment">// 接下来左端就是中间值</span><br>    <span class="hljs-type">int</span> pivot = arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (arr[high] &gt;= pivot &amp;&amp; high &gt; low)<br>            high--;<br><br>        <span class="hljs-built_in">swap</span>(arr[low], arr[high]);<br>        <span class="hljs-keyword">while</span> (arr[low] &lt;= pivot &amp;&amp; high &gt; low)<br>            low++;<br><br>        <span class="hljs-built_in">swap</span>(arr[low], arr[high]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果只是选择了默认的第一个元素作为枢纽的话，容易取到最大或者最小元素，可以换做取左中右的元素的中值作为枢纽值。</p><ol start="2"><li>优化不必要的交换</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对一个子数组进行划分，并返回基准元素的索引</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 选择第一个元素作为基准</span><br>    <span class="hljs-comment">// int pivot = arr[low];</span><br>    <span class="hljs-comment">// 优化三数取中作为基准</span><br>    <span class="hljs-type">int</span> m = low + (high - low) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (arr[low] &gt; arr[high])<br>        <span class="hljs-comment">// 左右保证左端小</span><br>        <span class="hljs-built_in">swap</span>(arr[low], arr[high]);<br>    <span class="hljs-keyword">if</span> (arr[m] &gt; arr[high])<br>        <span class="hljs-comment">// 中右保证中间小</span><br>        <span class="hljs-built_in">swap</span>(arr[m], arr[high]);<br>    <span class="hljs-keyword">if</span> (arr[m] &gt; arr[low])<br>        <span class="hljs-comment">// 左中保证中间小</span><br>        <span class="hljs-built_in">swap</span>(arr[m], arr[low]);<br>    <span class="hljs-comment">// 接下来左端就是中间值</span><br>    <span class="hljs-type">int</span> pivot = arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (arr[high] &gt;= pivot &amp;&amp; high &gt; low)<br>            high--;<br>        arr[low] = arr[high];<br>        <span class="hljs-keyword">while</span> (arr[low] &lt;= pivot &amp;&amp; high &gt; low)<br>            low++;<br>        arr[high] = arr[low];<br>    &#125;<br>    arr[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>非递归快速排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 非递归实现升序快速排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortNonRecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取数组长度</span><br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 创建一个栈来存储待处理的子数组区间</span><br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; s;<br>    <span class="hljs-comment">// 将整个数组区间入栈</span><br>    s.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-comment">// 弹出栈顶区间</span><br>        <span class="hljs-keyword">auto</span> p = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 获取区间左右端点</span><br>        <span class="hljs-type">int</span> low = p.first;<br>        <span class="hljs-type">int</span> high = p.second;<br><br>        <span class="hljs-keyword">if</span> (low &lt; high)<br>        &#123;<br>            <span class="hljs-comment">// 对当前区间进行划分，并获取基准索引</span><br>            <span class="hljs-type">int</span> pivotIndex = <span class="hljs-built_in">partition</span>(arr, low, high);<br>            <span class="hljs-comment">// 将左右两个子区间入栈</span><br>            s.<span class="hljs-built_in">push</span>(&#123;low, pivotIndex - <span class="hljs-number">1</span>&#125;);<br>            s.<span class="hljs-built_in">push</span>(&#123;pivotIndex + <span class="hljs-number">1</span>, high&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>来回交换不如直接赋值</p><h2 id="堆排序">堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 调整大根堆的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化最大元素的索引为当前节点</span><br>    <span class="hljs-type">int</span> largest = i;<br>    <span class="hljs-comment">// 左子节点的索引</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右子节点的索引</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 如果左子节点存在且比当前节点大，更新最大元素的索引</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果右子节点存在且比当前节点大，更新最大元素的索引</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>    &#123;<br>        largest = right;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果最大元素不是当前节点，交换它们，并递归调整被交换的子树</span><br>    <span class="hljs-keyword">if</span> (largest != i)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br>        <span class="hljs-built_in">heapify1</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp, j;<br>    temp = arr[i];<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; j &lt; n; j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; arr[j] &lt; arr[j + <span class="hljs-number">1</span>])<br>        &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp &gt;= arr[j])<br>            <span class="hljs-keyword">break</span>;<br>        arr[i] = arr[j];<br>        i = j;<br>    &#125;<br>    arr[i] = temp;<br>&#125;<br><br><span class="hljs-comment">// 堆排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构建大根堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始向上调整</span><br>        <span class="hljs-built_in">heapify2</span>(arr, n, i);<br>    &#125;<br>    <span class="hljs-comment">// 交换堆顶元素和末尾元素，并重新调整堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// 将最大元素放到数组末尾</span><br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-comment">// 将剩余元素重新调整为大根堆</span><br>        <span class="hljs-built_in">heapify2</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三五法则</title>
    <link href="/2023/03/05/old/%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99/"/>
    <url>/2023/03/05/old/%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。在C++11新标准之后，一个类还可以定义一个移动构造函数和一个移动赋值运算符。</p><p>C++并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义所有。但是这些操作通常应该被看做是一个整体。通常，只需要其中一个操作而不需要定义所有操作的情况是很少见的。三法则就是指析构函数，拷贝构造，拷贝赋值。</p><p>通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员（析构时需要手动去释放指针指向的内存）。</p><p>所以，若存在自定义（且正确）的析构函数，但使用合成的拷贝构造函数，那么拷贝过去的也只是指针，此时两个对象的指针变量同时指向同一块内存，指向同一块内存的后果很有可能是在两个对象中的析构函数中先后被释放两次。所以需要额外的拷贝控制函数去控制相应资源的拷贝。</p><p>所以这类例子的共同点就是：一个对象拥有额外的资源（指针指向的内存），但另一个对象使用合成的拷贝构造函数也同时拥有这块资源。当一方对象被销毁后，析构函数释放了资源，这时另一个对象便失去了这块资源（但程序员还不知道）。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector优化</title>
    <link href="/2023/03/02/old/vector%E4%BC%98%E5%8C%96/"/>
    <url>/2023/03/02/old/vector%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>先回顾这个程序，想想这是什么结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vertex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">vertex</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;created!!!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">vertex</span>(<span class="hljs-type">const</span> vertex&amp; other)<br>        : <span class="hljs-built_in">x</span>(other.x), <span class="hljs-built_in">y</span>(other.y)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copied!!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vertex&gt; nums;<br>    <span class="hljs-comment">//nums.push_back(vertex&#123; 1,2 &#125;);</span><br>    <span class="hljs-comment">//nums.push_back(vertex&#123; 3,4 &#125;);</span><br>    <span class="hljs-comment">//nums.push_back(vertex&#123; 5,6 &#125;);</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    nums.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">5</span>);<br>    cout &lt;&lt; nums.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    nums.<span class="hljs-built_in">emplace_back</span>( <span class="hljs-number">1</span>,<span class="hljs-number">2</span> );<br>    nums.<span class="hljs-built_in">emplace_back</span>( <span class="hljs-number">3</span>,<span class="hljs-number">4</span> );<br>    nums.<span class="hljs-built_in">emplace_back</span>( <span class="hljs-number">5</span>,<span class="hljs-number">6</span> );<br>    cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣x数之和你搞明白了吗</title>
    <link href="/2023/01/17/old/%E5%8A%9B%E6%89%A3x%E6%95%B0%E4%B9%8B%E5%92%8C%E4%BD%A0%E6%90%9E%E6%98%8E%E7%99%BD%E4%BA%86%E5%90%97/"/>
    <url>/2023/01/17/old/%E5%8A%9B%E6%89%A3x%E6%95%B0%E4%B9%8B%E5%92%8C%E4%BD%A0%E6%90%9E%E6%98%8E%E7%99%BD%E4%BA%86%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>反正这一堆几数之和当时是把我给整懵逼了，这里将三个题目总结一下，熟悉<strong>双指针</strong>的应用。</p><h2 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>暴力枚举是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度的，有没有可能只遍历一次就发现有没有两数之和为<code>target</code>呢。</p><p>答案是可以的，因为之前遍历过的数是可以存储起来的，当我们再遇到一个元素能跟已经存储起来的某个元素加和为<code>target</code>即可返回。而且我们需要存储元素对应的下标，很容易想到哈希表，<code>key</code>为元素，<code>value</code>为下标。边遍历边检查即可</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-comment">//如果能找到一个过去的元素加上当前元素为target，则直接返回</span><br>            <span class="hljs-keyword">auto</span> iter = map1.<span class="hljs-built_in">find</span>(target-nums[i]);<br>            <span class="hljs-keyword">if</span>(iter!=map1.<span class="hljs-built_in">end</span>()) <br>            &#123;<br>                <span class="hljs-keyword">return</span> &#123;i,iter-&gt;second&#125;;<br>            &#125;<br>            <span class="hljs-comment">//否则将其记录在哈希表里。</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map1[nums[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><table><thead><tr><th>容器</th><th>底层</th><th>是否有序</th><th>key是否可重复</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td>按key有序</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multimap</td><td>红黑树</td><td>按key有序</td><td>是</td><td>O(logn</td><td>O(logn)</td></tr><tr><td>unordered_map</td><td>哈希表</td><td>无序</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>如果不需要考虑有序无序问题的情况下，可以考虑用<strong>unordered_map</strong>，其查询效率和增删效率更优。</p><hr><h2 id="三数之和"><a href="https://leetcode.cn/problems/3sum">三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路-2">思路</h3><p>此题用哈希表没有用双指针方便。首先将整个数组<strong>排序</strong>，对其中每一个元素进行遍历，假如当前元素为<code>nums[i]</code>，若能在其后找到两个元素之和为<code>-nums[i]</code>则满足题目条件。将两个指针分别置于i之后的子数组的两端，若两指针所指元素之和大于<code>-nums[i]</code>，亦即三数之和大于零，说明大了，则将右指针减一；否则将左指针加一。</p><p>是不是能做一些<strong>剪枝</strong>处理呢，当然可以，如果在对每一个元素进行遍历的过程中，发现这一个元素等于上一个元素，即可跳过。此外，当遍历到一个元素发现其已经大于零，也可直接返回，因为后面的元素都比该元素大了，不可能组成和为零。当双指针从两侧向中间靠拢时，遇到与前一个元素相同的情况也可以跳过。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = nums[i];<br>            <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>)     <span class="hljs-comment">//剪枝</span><br>                <span class="hljs-keyword">return</span> ans;<br>            <span class="hljs-type">int</span> left = i+<span class="hljs-number">1</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])     <span class="hljs-comment">//剪枝</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(right&gt;left)<br>            &#123;<br>                <span class="hljs-type">int</span> temp_sum = a+nums[left]+nums[right];<br>                <span class="hljs-keyword">if</span>(temp_sum&gt;<span class="hljs-number">0</span>)<br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp_sum&lt;<span class="hljs-number">0</span>)<br>                    left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;a,nums[left],nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right<span class="hljs-number">-1</span>])   <span class="hljs-comment">//去重</span><br>                        right--;<br>                    <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])     <span class="hljs-comment">//去重</span><br>                        left++;<br>                    <span class="hljs-comment">//找到一个答案之后双指针收缩。</span><br>                    right--;<br>                    left++;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四数之和"><a href="https://leetcode.cn/problems/4sum">四数之和</a></h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code> 你可以按 任意顺序 返回答案 。</li></ul><p></p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,0,<span class="hljs-string">-1</span>,0,<span class="hljs-string">-2</span>,2], target = 0<br>输出：[[<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,1,2],[<span class="hljs-string">-2</span>,0,0,2],[<span class="hljs-string">-1</span>,0,0,1]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：<span class="hljs-string">[[2,2,2,2]]</span><br></code></pre></td></tr></table></figure><h3 id="思路-3">思路</h3><p>与三数之和类似，对于每个元素遍历其后的每一个元素，这时便确定了两个元素 <code>nums[i]</code> 和 <code>nums[j]</code> ，我们需要再其后找到两个元素的和为 <code>target - nums[i] - nums[j]</code> 即可。但是注意这里 <code>target</code> 为任意值，主循环中如果使用 <code>if(nums[i]&gt;target) return ans;</code> 剪枝则是错误的。因为 <code>target</code> 可以是任意值，比如说target为 <code>-11</code> ，排序完的的数组前两个是 <code>-5,-4...</code> ，那你一碰到 <code>-5</code> 就直接返回了，肯定是不对的。（我绝对不会告诉你我就是在这犯错的）</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">//这样是错的！</span><br>            <span class="hljs-comment">// if (nums[i] &gt; target)</span><br>            <span class="hljs-comment">//     return ans;</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left)<br>                &#123;<br>                    <span class="hljs-type">long</span> temp_sum = (<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span> (temp_sum &gt; target)<br>                        right--;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp_sum &lt; target)<br>                        left++;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                            right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                            left++;<br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="/2022/07/30/old/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/07/30/old/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>简单点来说，就是假设B复制了A；</p><p>当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是<strong>浅拷贝</strong>；</p><p>如果B没变，那就是<strong>深拷贝</strong>。</p><h2 id="浅拷贝报错">浅拷贝报错</h2><p>来看这样一段程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_buffer;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//String(const String&amp; other)</span><br>    <span class="hljs-comment">//    : size(other.size)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    m_buffer = new char[size + 1];</span><br>    <span class="hljs-comment">//    memcpy(m_buffer, other.m_buffer, size + 1);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* string)<br>    &#123;<br>        size = <span class="hljs-built_in">strlen</span>(string);<br>        m_buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(m_buffer, string, size + <span class="hljs-number">1</span>);<br>        m_buffer[size] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">char</span>* buffer, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br>        : <span class="hljs-built_in">m_buffer</span>(buffer), <span class="hljs-built_in">size</span>(size) &#123;&#125;<br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] m_buffer;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string);<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string)<br>&#123;<br>    <span class="hljs-keyword">return</span> stream &lt;&lt; string.m_buffer;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String string = <span class="hljs-string">&quot;jumping&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">other</span><span class="hljs-params">(string)</span></span>;<br>    cout &lt;&lt; string &lt;&lt; other &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><div style="text-align:center;"><img src="/img/cpp/deep_copy1.png" style="zoom: 67%;" /></div><!-- ![深拷贝报错](/img/cpp/deep_copy1.png) --><p>运行该程序会出现这样的报错，让我们来看一下为什么。</p><p>实际上默认的拷贝构造函数就是如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; other)&#123;<br>    <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>, &amp;other, <span class="hljs-built_in">sizof</span>(String));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于成员变量m_buffer来说，他只是一个指针，你只是将一个指针的值复制过去。复制得到的新String对象中，其m_buffer与原来的指向的是同一块地址，栈变量生存期结束后，第一个String调用析构函数释放了内存。而当other调用析构函数的时候，是在释放一块已经被释放了的内存，就会出错，因为这一块内存已经不“属于我们”了。</p><h2 id="写深拷贝">写深拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *m_buffer;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重新写了拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other)<br>        : <span class="hljs-built_in">size</span>(other.size)<br>    &#123;<br>        m_buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(m_buffer, other.m_buffer, size + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *string)<br>    &#123;<br>        size = <span class="hljs-built_in">strlen</span>(string);<br>        m_buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(m_buffer, string, size + <span class="hljs-number">1</span>);<br>        m_buffer[size] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br>        : <span class="hljs-built_in">m_buffer</span>(buffer), <span class="hljs-built_in">size</span>(size) &#123;&#125;<br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] m_buffer;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;stream, <span class="hljs-type">const</span> String &amp;string);<br>&#125;;<br><br>std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;stream, <span class="hljs-type">const</span> String &amp;string)<br>&#123;<br>    <span class="hljs-keyword">return</span> stream &lt;&lt; string.m_buffer &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String string = <span class="hljs-string">&quot;Jumping&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">other</span><span class="hljs-params">(string)</span></span>;<br>    std::cout &lt;&lt; string &lt;&lt; other;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新写了拷贝构造函数进行“深拷贝”。在拷贝构造的时候，重新new一段堆上的内存，此时两个指针就指向两端不同的内存了。当然可以析构两次。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多态</title>
    <link href="/2022/05/26/old/%E5%A4%9A%E6%80%81/"/>
    <url>/2022/05/26/old/%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="如何实现多态">如何实现多态</h2><p>C++ 中的多态可以通过重载或虚函数重写实现。</p><ol><li>重载，静态多态<br>编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b)</span><span class="hljs-comment">//2</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">Add</span>(<span class="hljs-number">666</span>,<span class="hljs-number">888</span>)&lt;&lt;endl;<span class="hljs-comment">//1</span><br>    cout&lt;&lt;<span class="hljs-built_in">Add</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>);<span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>重写，动态多态<br>虚函数是一种特殊的函数，允许在派生类中重写基类中的定义。当一个指向基类的指针指向一个派生类对象时，编译器会根据指针所指向的实际对象的类型来调用虚函数。</li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">csharpCopy codeclass Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shape::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square::draw&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果我们有一个指向 Shape 的指针，并且它指向一个 Circle 对象，则当我们调用 draw() 函数时，编译器会自动调用 Circle::draw() 函数，而不是 Shape::draw() 函数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">scssCopy codeShape *s <span class="hljs-operator">=</span> new Circle()<span class="hljs-comment">;</span><br>s-&gt;draw()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">cCopy <span class="hljs-built_in">code</span><br>Circle::<span class="hljs-built_in">draw</span><br></code></pre></td></tr></table></figure><p>这就是 C++ 中的多态，它允许我们通过一个基类指针来访问多个不同的派生类对象，并且在运行时自动调用正确的虚函数。</p><h2 id="虚函数与纯虚函数">虚函数与纯虚函数</h2><p>在 C++ 中，虚函数和纯虚函数是多态的重要实现方式。它们的主要区别如下：</p><ol><li>虚函数：虚函数是在基类中定义的一种特殊的函数，其子类可以重写它以实现多态。</li><li>纯虚函数：纯虚函数是一种特殊的虚函数，它仅在基类中声明，没有任何实现。纯虚函数的作用是让基类成为抽象类，不能创建基类的对象，只能创建其子类对象。其子类必须实现该纯虚函数，否则子类也是一个抽象类。含有纯虚拟函数的类称为抽象类，它不能生成对象；</li></ol><p>不同的是，虚函数可以被子类重写，而纯虚函数必须要被子类重写，不能被实例化。虚函数的作用是实现多态，而纯虚函数的作用是让子类实现某些特定的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am a person&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//纯虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_name</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>string name;<br><span class="hljs-built_in">man</span>(string name = <span class="hljs-string">&quot;default&quot;</span>) : <span class="hljs-built_in">name</span>(name) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am a man&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_name</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; name &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person* ptr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">man</span>();<br>ptr1-&gt;<span class="hljs-built_in">print_name</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，虚函数是用来实现多态的，含有纯虚函数的类称作抽象类。</p><p>虚函数和纯虚函数与虚表有关。</p><p>虚表（Virtual Table）是一个指针数组，每个数组元素都指向一个虚函数。每个类的对象都有一个虚指针（Virtual Pointer），该指针指向该类的虚表。</p><p>在 C++ 中，当一个虚函数被调用时，编译器会通过该对象的虚指针找到其对应的虚表，然后根据函数在虚表中的位置调用相应的函数。因此，如果一个函数是虚函数，则其实现在运行时才能确定，这就是多态的实现方式。</p><p>而纯虚函数是在基类中声明的，其子类必须实现该函数，因此虚表的实现是基于纯虚函数的。</p><h2 id="为什么要有虚函数、虚表这种东西">为什么要有虚函数、虚表这种东西</h2><p>假如有两个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am a person&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am a man&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person* ptr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">man</span>();<br>ptr1-&gt;<span class="hljs-built_in">desc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C++中类和操作的封装只是对于程序员而言的</strong>。而编译器编译之后其实还是面向过程的代码。编译器帮你给成员函数增加一个额外的类指针参数，运行期间传入对象实际的指针。这段程序的打印结果是<code>I am a person</code>，因为这里没有声明父类desc为虚函数，因此属于静态绑定。<strong>类的数据(成员变量)和操作(成员函数)其实还是分离的</strong>。仅从对象的内存布局来看，只能看到成员变量，看不到成员函数。因为调用哪个函数是编译期间就确定了的，编译期间只能识别父类的desc。</p><p>也就是说在含有虚函数的类编译期间，编译器会自动给这种类在起始位置追加一个虚表指针(称之为: vptr) 。vptr指向一个虚表(称之为: vtable 或 vtbl) ，虚表中存储了实际的函数地址。所有虚函数的的调用取的是哪个函数（地址）是在运行期间通过查虚表确定的。</p><h2 id="虚析构函数，为什么没有虚构造函数">虚析构函数，为什么没有虚构造函数</h2><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p><ul><li><p>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</p></li><li><p>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</p></li></ul><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><p>不能虚构造：</p><ul><li><p>从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。</p></li><li><p>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p></li><li><p>从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣链表经典题</title>
    <link href="/2022/02/18/old/%E5%8A%9B%E6%89%A3%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <url>/2022/02/18/old/%E5%8A%9B%E6%89%A3%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>链表是数据结构与算法中常考的内容，指针更是c语言中的重中之重，学号指针的操作对于学好c、c++至关重要。这里总结几道经典的算法题目。</p><h2 id="力扣206-反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣206.反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>这道题不用我说多经典了吧，当年大一学c语言指针时的课堂作业就是这道题。很容易想到从头到尾修改每一个结点的 <code>next</code> 指针。但是修改了当前节点的 <code>next</code> 之后，怎么找它原来的下一个节点呢？所以需要在修改当前节点 <code>next</code> 指针前提前保存它原来的下一个结点。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>, *tmp, *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)<br>        &#123;<br>            tmp = cur-&gt;next;    <span class="hljs-comment">//提前保存下一个节点</span><br>            cur-&gt;next = pre;    <span class="hljs-comment">//修改当前节点</span><br>            pre = cur;          <span class="hljs-comment">//移动指向当前结点前一个结点的指针</span><br>            cur = tmp;          <span class="hljs-comment">//移动指向当前结点的指针</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="力扣138-复制带随机指针的链表"><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">力扣138. 复制带随机指针的链表</a></h2><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><h3 id="思路-2">思路</h3><p>由于要复制的链表还含有一个指针域 <code>random</code> 指向一个随机结点，如果我们只是按照 <code>next</code> 依次复制的话，可能会出现某结点的 <code>random</code> 指针指向一个暂时不存在的节点的情况。</p><p>第一种思路是从一个结点开始不断检查其两个指针域指向的节点创建了没有，将此过程视为一个递归的过程，每创建一个新结点，便将指向其的指针与该结点加入到哈希表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;Node*,Node*&gt;map1;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//递归出口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">find</span>(head)==map1.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            Node *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            map1[head] = newnode;<br>            newnode-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>            newnode-&gt;next=<span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>        &#125;<br>            <span class="hljs-keyword">return</span> map1[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实际项目中是尽可能避免递归的，能不能想到迭代的方法呢。我当时也没想到（我是笨蛋）。这里总结一下题解的方法。可以先将每个节点向后复制一下。假如一个链表最开始为：</p><p><code>1-&gt;2-&gt;3-&gt;4-&gt;null</code></p><p>向后复制</p><p><code>1-&gt;(1)-&gt;2-&gt;(2)-&gt;3-&gt;(3)-&gt;4-&gt;(4)-&gt;null</code></p><p>其中括号内的为新创建的复制出来的结点，这里的关键点是，复制节点的 <code>next</code> 指针自然是指向被复制结点在复制操作前的下一个结点，复制节点的 <code>random</code> 指针则指向被复制结点 <code>random</code> 指向的结点的下一个结点。（仔细思考这个过程）。</p><p>最后只需要按照原结点和复制结点对链表进行拆分即可。这个方法能总结许多经验。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span>(Node* tmp = head;tmp!=<span class="hljs-literal">NULL</span>;tmp = tmp-&gt;next-&gt;next)<br>        &#123;<br>            Node* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(tmp-&gt;val);<br>            newnode-&gt;next = tmp-&gt;next;<br>            tmp-&gt;next = newnode;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Node* tmp = head;tmp!=<span class="hljs-literal">NULL</span>;tmp = tmp-&gt;next-&gt;next)<br>        &#123;<br>            Node* newnode = tmp-&gt;next;<span class="hljs-comment">//对于每个复制节点</span><br>            newnode-&gt;random = (tmp-&gt;random==<span class="hljs-literal">NULL</span>)?<span class="hljs-literal">NULL</span>:tmp-&gt;random-&gt;next;      <br>        &#125;<br>        Node* ans = head-&gt;next;<br>        <span class="hljs-comment">//这个循环里就不是tmp = tmp-&gt;next-&gt;next了</span><br>        <span class="hljs-keyword">for</span>(Node *tmp = head;tmp!=<span class="hljs-literal">NULL</span>;tmp = tmp-&gt;next)<br>        &#123;<br>            Node* newnode = tmp-&gt;next;<span class="hljs-comment">//对于每个复制节点</span><br>            tmp-&gt;next = tmp-&gt;next-&gt;next;<br>            newnode-&gt;next = (newnode-&gt;next==<span class="hljs-literal">NULL</span>)?<span class="hljs-literal">NULL</span>:newnode-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数参数为指针时一般要额外检查该指针是否为空的情况。</p><p>当需要使用两次指针如 <code>tmp-&gt;next-&gt;next</code> 时需要检查 <code>tmp-&gt;next</code> 是否为 <code>NULL</code></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/2022/02/13/old/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/02/13/old/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例1</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>用元素的总数来控制总循环的次数，用四个变量控制当前螺旋的上下左右边。每一边遵循左闭右闭原则。每遍历完一条边之后向内收缩。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, bottom = m - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, nums = m * n;<br>        ans.<span class="hljs-built_in">resize</span>(nums);<br>        <span class="hljs-keyword">while</span> (index &lt; nums)<br>        &#123;<br>            <span class="hljs-comment">//! 从左到右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right &amp;&amp; index &lt; nums; i++)<br>            &#123;<br>                ans[index++] = matrix[top][i];<br>            &#125;<br>            top++; <span class="hljs-comment">//! 上边下移</span><br>            <span class="hljs-comment">//! 从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &lt;= bottom &amp;&amp; index &lt; nums; i++)<br>            &#123;<br>                ans[index++] = matrix[i][right];<br>            &#125;<br>            right--; <span class="hljs-comment">//! 右边左移</span><br>            <span class="hljs-comment">//! 从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left &amp;&amp; index &lt; nums; i--)<br>            &#123;<br>                ans[index++] = matrix[bottom][i];<br>            &#125;<br>            bottom--; <span class="hljs-comment">//! 下边上移</span><br>            <span class="hljs-comment">//! 从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bottom; i &gt;= top &amp;&amp; index &lt; nums; i--)<br>            &#123;<br>                ans[index++] = matrix[i][left];<br>            &#125;<br>            <span class="hljs-comment">//! 左边右移</span><br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵Ⅱ"><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵Ⅱ</a></h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例1</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><h3 id="思路-2">思路</h3><p>与上一题类似，用总元素数控制总循环，用四个变量控制当前螺旋的上下左右边。每一边遵循左闭右闭原则。每遍历完一条边之后向内收缩。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, bottom = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//初始化数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">while</span> (num &lt;= n*n ) &#123;<br><br>            <span class="hljs-comment">//从左到右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i) res[top][i] = num++;<br>            <span class="hljs-comment">//上边下移</span><br>            ++top;<br><br>            <span class="hljs-comment">//从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &lt;= bottom; ++i) res[i][right] = num++;<br>            <span class="hljs-comment">//右边左移</span><br>            --right;<br><br>            <span class="hljs-comment">//从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left; --i) res[bottom][i] = num++;<br>            <span class="hljs-comment">//下边上移</span><br>            --bottom;<br><br>            <span class="hljs-comment">//从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bottom; i &gt;= top; --i) res[i][left] = num++;<br>            <span class="hljs-comment">//左边右移</span><br>            ++left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯和搜索</title>
    <link href="/2022/01/30/old/%E5%9B%9E%E6%BA%AF%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/30/old/%E5%9B%9E%E6%BA%AF%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯是递归的“副产品”">回溯是递归的“副产品”</h2><p>回溯是一种搜索的方式，本质其实是穷举，可以通过剪枝来优化。回溯法主要需要注意三个方面。</p><ul><li>回溯函数的<strong>返回值</strong>与<strong>参数</strong>应该怎么设定</li><li>函数应该在什么时候返回，也就是递归的<strong>出口</strong>在哪里，总不能无穷无尽地递归下去吧。</li><li>回溯搜索的<strong>遍历</strong>过程是怎么样的。回溯法解决的问题都可以抽象成为一个树形结构，遍历就可以理解为一个节点有多少个孩子，是在做**“横向操作”<strong>。而递归是在朝叶子节点走，是在做</strong>“纵向操作”**</li></ul><p>回溯法的模板如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackTracking</span><span class="hljs-params">(参数)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ()<br>    &#123;<br>        <span class="hljs-comment">// 存放结果</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">//出口</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (遍历范围)<br>    &#123;<br>        <span class="hljs-comment">// 处理节点</span><br>        <span class="hljs-built_in">BackTracking</span>(参数); <span class="hljs-comment">// 遍历</span><br>    &#125;<br>    <span class="hljs-comment">// 回溯，撤销处理结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这玩意儿咋用的，来个题目练一下</p><h2 id="剑指-Offer-12-矩阵中的路径"><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 <code>3×4</code> 的矩阵中包含单词 <code>&quot;ABCCED&quot;</code>（单词中的字母已标出）。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], word = <span class="hljs-string">&quot;abcd&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>遍历的方向就是在矩阵内按上下左右四个方向进行遍历，如果当前矩阵中的字母与word中的对应字母相同，则进行递归。若碰到对应字母不相同，则返回。若到了word中最后一个字母判断仍然相同，则返回true。其次需要注意矩阵是有边界的，意味着不能超出边界，需要额外做判定条件。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; d;<br>    <span class="hljs-comment">//控制边界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">in_matrix</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;<br>    &#125;<br>    <span class="hljs-comment">//回溯</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BackTracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> now, string word)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//字符不匹配返回</span><br>        <span class="hljs-keyword">if</span> (word[now] != board[x][y])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//最后一个字符匹配成功返回</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> temp = board[x][y];<br>        board[x][y] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//朝上下左右遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> newx = x + d[i][<span class="hljs-number">0</span>], newy = y + d[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_matrix</span>(newx, newy))<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">BackTracking</span>(board, newx, newy, now + <span class="hljs-number">1</span>, word))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        board[x][y] = temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> start = word[<span class="hljs-number">0</span>];<br>        m = board.<span class="hljs-built_in">size</span>();<br>        n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> ans = <span class="hljs-literal">false</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; d1 = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>        d = d1;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-type">bool</span> temp_ans = <span class="hljs-built_in">BackTracking</span>(board, i, j, <span class="hljs-number">0</span>, word);<br>                <span class="hljs-keyword">if</span> (temp_ans)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="面试题13-机器人的运动范围"><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">面试题13. 机器人的运动范围</a></h2><p>地上有一个<code>m</code>行<code>n</code>列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当<code>k</code>为<code>18</code>时，机器人能够进入方格 <code>[35, 37]</code> ，因为<code>3+5+3+7=18</code>。但它不能进入方格 <code>[35, 38]</code>，因为<code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p><p></p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">2</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h3 id="思路-2">思路</h3><p>在回溯遍历的过程中额外假如一个判断条件判断能不能进入下一个位置即可，与前一题比较类似。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-comment">//新增条件数位之和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x)<br>        &#123;<br>            <span class="hljs-type">int</span> temp = x % <span class="hljs-number">10</span>;<br>            ans += temp;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">in_matrix</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;<br>    &#125;<br>    <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; d = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackTracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;known, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//如果不满足数位之和条件则返回</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cal_sum</span>(x) + <span class="hljs-built_in">cal_sum</span>(y) &gt; k)<br>            <span class="hljs-keyword">return</span> ;<br>        known[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//没新增一个可以访问的坐标ans++，并标记成为已经访问</span><br>        ans++;<br>        <span class="hljs-comment">//遍历上下左右的坐标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> newx = x + d[i][<span class="hljs-number">0</span>], newy = y + d[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//如果超出边界或者已经访问过了就不递归了</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_matrix</span>(newx, newy) &amp;&amp; !known[newx][newy])<br>            &#123;<br>                <span class="hljs-built_in">BackTracking</span>(known, newx, newy, k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m = m, <span class="hljs-keyword">this</span>-&gt;n = n;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">known</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-number">0</span>));<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">BackTracking</span>(known, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/2022/01/20/old/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/20/old/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>特点与区别：<br>深度优先搜索和广度优先搜索都是遍历一个图的算法，两种遍历方法的主要特点是</p><ul><li>深度优先：不撞南墙不回头。</li><li>广度优先：由开始向外扩散。</li></ul><p>现在可能听起来很让人疑惑，接下来我们逐个来分析：</p><h2 id="深度优先搜索">深度优先搜索</h2><p>深度优先搜索(Depth First Search):的主要思路是沿着一条路径一直走，直到走不动的时候再回头。什么时候叫走不动的时候呢，当访问到一个图中一个结点时，该结点已经没有任何的<strong>邻接的且未访问</strong>的结点时，此时可形象地称为走不动了，撞了南墙了。<br>深度优先搜索的实现往往和一种数据结构——<strong>栈</strong>联系在一起，具体思路如下：</p><ol><li>设定一个遍历的起点，并将其入栈；</li><li>访问并弹出栈顶结点，将栈顶结点的<strong>邻接的且未访问</strong>的结点入栈；</li><li>重复步骤2，直到栈为空；</li></ol><p>C++代码实现如下(图以邻接矩阵存储为例，以结点的序号来表示结点，后文均用邻接矩阵作为代码示例)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;search_sta;<br>    vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">visited</span>(size,<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> temp_node;<br>    search_sta.<span class="hljs-built_in">push</span>(start);     <span class="hljs-comment">//起点入栈</span><br>    visited.<span class="hljs-built_in">push_back</span>(start);   <span class="hljs-comment">//标为已知</span><br>    <span class="hljs-keyword">while</span>(!search_sta.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        temp_node = search_sta.<span class="hljs-built_in">top</span>();   <span class="hljs-comment">//获取栈顶元素</span><br>        <span class="hljs-built_in">visit</span>(temp_node);               <span class="hljs-comment">//访问该节点</span><br>        search_sta.<span class="hljs-built_in">pop</span>();               <span class="hljs-comment">//栈顶元素出栈</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(graph[temp_node][i]&amp;&amp;visited[i]==<span class="hljs-literal">false</span>)<br>            &#123;<br>                <span class="hljs-comment">//将未访问的邻接点入栈并标为已访问</span><br>                search_sta.<span class="hljs-built_in">push</span>(i);<br>                visited[i]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们也可以用<strong>递归</strong>的方式来实现dfs，事实上递归也是一种栈，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt;visited;<span class="hljs-comment">//提前初始化visited数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_recursion</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">visit</span>(start);   <span class="hljs-comment">//访问结点</span><br>    visited[start]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(visited[i]==<span class="hljs-literal">false</span>&amp;&amp;graph[start][i])<br>        &#123;<br>            <span class="hljs-built_in">dfs_recursion</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><p>广度优先搜索(Breadth First Search)的主要思路是从起点开始，访问其所有邻接点，再依次访问这每个邻接点的所有邻接点（好像有点绕）。与深度优先搜索所不同的是，广度优先搜索对于每个结点和它的邻接点都尝试去访问。从直观上来看，bfs是一层一层的，第一层访问最近一圈的结点，而后层数随着圈不断向外扩展。<br>广度优先搜索的实现往往和另一种数据结构——<strong>队列</strong>有关，具体思路如下：</p><ol><li>设定一个遍历的起点，将起点入队；</li><li>访问队头结点并将其出队，将队头结点的所有<strong>邻接且未访问</strong>结点入队；</li><li>重复步骤2直到队为空；</li></ol><p>C++实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(graph.size(),<span class="hljs-literal">false</span>)</span></span>;<br>    q.<span class="hljs-built_in">push</span>(i);<br>    visited[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> temp_node = q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//获取队首元素</span><br>        <span class="hljs-built_in">visit</span>(temp_node);           <span class="hljs-comment">//访问该节点</span><br>        q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">//弹出队首元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (graph[temp_node][j] == <span class="hljs-number">1</span> &amp;&amp; visited[j] == <span class="hljs-literal">false</span>)<br>            &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/01/18/old/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/01/18/old/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>在有序表中查找元素，优先考虑二分查找！</p><h2 id="两种写法">两种写法</h2><p>循环条件到底是 <code>left&lt;=right</code> 还是 <code>left&lt;right</code> 呢, 修改端点的时候是 <code>right=middle</code> 还是 <code>right = middle-1</code> 呢。这里的关键点是搞清楚查找区间的定义。二分查找的查找区间的定义有两种，分别为 <code>[left,right]</code> 和 <code>[left，right)</code> 。基于这两种定义，有两种不一样的写法。</p><h3 id="写法一">写法一</h3><ul><li>当区间的定义为 <code>[left,right]</code> 时，<code>left</code> 与 <code>right</code> 相等是有意义的，因此循环体的条件应为 <code>while(left&lt;=right)</code></li><li>如果 <code>nums[mid]&lt;target</code> 说明目标元素在右半侧，又因为 <code>nums[mid]</code> 不等于 <code>target</code> ，所以 <code>left</code> 应修改为 <code>mid+1</code> ，表示下一次在 <code>[mid+1,right]</code> 中搜索元素。同理，若 <code>nums[mid]&gt;target</code> ，则将 <code>right</code> 修改为 <code>mid-1</code> ，表示下一次在 <code>[left,mid-1]</code> 中搜索目标元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> middle = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[middle] == target)<br>            <span class="hljs-keyword">return</span> middle;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target)<br>            left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = middle - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">//没找求着</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写法二">写法二</h3><ul><li>当区间的定义为 <code>[left,right)</code> 时， <code>left</code> 与 <code>right</code> 相等是没有意义的。因此循环的条件为 <code>while(left&lt;right)</code></li><li>如果 <code>nums[mid]&lt;target</code> 说明目标元素在右半侧，又因为 <code>nums[mid]</code> 不等于 <code>target</code> ，所以 <code>left</code> 应修改为 <code>mid+1</code> ，表示下一次在 <code>[mid+1,right)</code> 中搜索元素。但若 <code>nums[mid]&gt;target</code> ，则应将 <code>right</code> 修改为 <code>mid</code> ，表示下一次在 <code>[left,mid)</code> 中搜索目标元素，如果是修改为 <code>mid-1</code> 的话，下一次就是在 <code>[left,mid-1)</code> 中搜索目标元素了，而 <code>mid-1</code> 却有可能是目标元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> middle = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[middle] == target)<br>            <span class="hljs-keyword">return</span> middle;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target)<br>            left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = middle;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">//没找求着</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面来个题目练练手，学完东西一定要练习！</p><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h2><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>这种题其实容易想到的是哈希，但是要是面试问这道题不会是想考哈希的，题目也暗示你了是<strong>有序数组</strong>，提示你可以考虑下<strong>二分查找</strong>。但是怎么确定出现的次数呢，我们通过二分查找找到目标元素后，通过检查 <code>left</code> 和 <code>right</code> 的对应的值来缩小对应区间，直到 <code>left</code> 为第一个 <code>target</code> ， <code>right</code> 为最后一个 <code>target</code> ，最后返回 <code>right-left+1</code> 即可。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <br>                <span class="hljs-keyword">while</span>(nums[right]!=target)&#123; right--; &#125;<br>                <span class="hljs-keyword">while</span>(nums[left]!=target)&#123; left++; &#125;  <br>                <span class="hljs-keyword">return</span> right-left+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right-left+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>万一第一次准备执行 <code>while(nums[right]!=target)&#123; right--; &#125;</code> 之前 <code>nums[left]</code> 已经不是最后一个 <code>target</code> 了怎么办，但其实这种情况是不存在的，因为之前移动 <code>left和right</code> 的时候，已经保证 <code>left</code> 和 <code>right</code> 最多是两端了。例如我们在移动 <code>left</code> 时的判断条件为： <code>if(nums[mid]&lt;target)</code>，当其为 <code>true</code> 时，首先 <code>nums[mid]</code> 是小于 <code>target</code> 的，那么我们令 <code>left = mid+1</code> 时， <code>left</code> 最多时第一个 <code>target</code> ，不可能是第二、三、四、五等等。同理 <code>right</code> 也最多是最后一个 <code>target</code> ，而不可能是倒数第二、三、四等等</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯和搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
